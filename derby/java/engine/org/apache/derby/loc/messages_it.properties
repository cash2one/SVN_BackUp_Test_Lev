###################################################
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
###################################################

###################################################
#
# DO NOT EDIT THIS FILE!
#
# Instead, edit messages.xml. The ant MessageBuilder task takes
# messages.xml as input and from it generates this file.
#
###################################################


01001=\u00C8 stato effettuato un tentativo di aggiornare o eliminare una riga gi\u00E0 eliminata: nessuna riga \u00E8 stata aggiornata o eliminata.

01003=I valori nulli sono stati eliminati dall''argomento di una funzione della colonna.

# Arguments:
#
#    {0} = authorizationID
#
01006=Privilegio non revocato dall''utente {0}.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
01007=Ruolo {0} non revocato dall''ID di autenticazione {1}.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
01008=Clausola WITH ADMIN OPTION del ruolo {0} non revocata dall''ID di autenticazione {1}.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
01009=Colonna generata {0} eliminata dalla tabella {1}.

0100E=Tentativo di restituire un numero eccessivo di set di risultati. 

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
01500=Il vincolo {0} sulla tabella {1} \u00E8 stato eliminato.

# Arguments:
#
#    {0} = viewName
#
01501=La vista {0} \u00E8 stata eliminata.

# Arguments:
#
#    {0} = triggerName
#    {1} = tableName
#
01502=Il trigger {0} sulla tabella {1} \u00E8 stato eliminato.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
01503=La colonna {0} sulla tabella {1} \u00E8 stata modificata aggiungendo un vincolo non nullo.

# Arguments:
#
#    {0} = indexName
#
01504=Il nuovo indice \u00E8 un duplicato di uno esistente: {0}.

# Arguments:
#
#    {0} = dataValue
#
01505=Il valore {0} potr\u00E0 essere troncato.

# Arguments:
#
#    {0} = synonymName
#    {1} = objectName
#
01522=Il sinonimo ''{0}'' definito di recente \u00E8 stato risolto nell''oggetto ''{1}'' attualmente non definito.

# Arguments:
#
#    {0} = databaseName
#
01J01=Database ''{0}'' non creato, connessione eseguita al database esistente.

01J02=I cursori sensibili allo scorrimento non sono attualmente implementati.

# Arguments:
#
#    {0} = className
#    {1} = columnName
#
01J04=La classe ''{0}'' per la colonna ''{1}'' non implementa java.io.Serializable o java.sql.SQLData. Le istanze devono implementare una di queste interfacce per poter essere memorizzate.

01J05=Aggiornamento database riuscito. Il database aggiornato \u00E8 pronto per l''uso. Nuova convalida delle istruzioni preparate memorizzate non riuscita. Per i dettagli relativi a questo errore, vedere l''eccezione successiva.

01J06=ResultSet non aggiornabile. La query non \u00E8 qualificata per la generazione di un ResultSet aggiornabile.

01J07=ResultSetHoldability limitato a ResultSet.CLOSE_CURSORS_AT_COMMIT per una transazione globale.

# Arguments:
#
#    {0} = resultSetType
#    {1} = resultSetType
#
01J08=Impossibile aprire il tipo resultSet {0}. Tipo ResultSet {1} aperto.

01J10=I set di risultati sensibili allo scorrimento non sono supportati dal server; eseguire un nuovo mapping al cursore di tipo forward-only

01J12=Impossibile acquisire il testo del messaggio dal server. Vedere l''eccezione successiva. La stored procedure SYSIBM.SQLCAMESSAGE non \u00E8 installata sul server. Contattare l''amministratore del database.

# Arguments:
#
#    {0} = number
#
01J13=Il numero di righe restituite ({0}) \u00E8 troppo grande per essere un numero intero; il valore restituito verr\u00E0 troncato.

01J14=L''autorizzazione SQL viene utilizzata senza prima abilitare l''autenticazione.

# Arguments:
#
#    {0} = remainingDays
#    {1} = databaseName
#
01J15=La password scade tra {0} giorno/i. Usare la procedura SYSCS_UTIL.SYSCS_MODIFY_PASSWORD per cambiare la password nel database ''{1}''.

# Arguments:
#
#    {0} = databaseName
#
01J16=La password non \u00E8 pi\u00F9 valida. Per proteggere il database, \u00E8 necessario aggiornare subito la password. Usare la procedura SYSCS_UTIL.SYSCS_MODIFY_PASSWORD per cambiare la password nel database ''{0}''.

01J17=Impossibile cifrare, cifrare di nuovo o decifrare un database gi\u00E0 avviato. Prima di tentare queste operazioni \u00E8 necessario chiudere il database.

07000=Almeno un parametro sull''istruzione corrente non \u00E8 inizializzato.

# Arguments:
#
#    {0} = parameterName
#    {1} = procedureName
#
07004=Il parametro {0} \u00E8 un parametro della procedura {1} e deve essere registrato con CallableStatement.registerOutParameter prima dell''esecuzione.

07009=Nessun parametro di input.

08000=Connessione chiusa a causa di un''interruzione sconosciuta.

08001.C.10=Non \u00E8 stato possibile stabilire una connessione perch\u00E9 la dimensione del token di sicurezza supera la dimensione massima consentita dal protocollo di rete.

08001.C.11=Non \u00E8 stato possibile stabilire una connessione perch\u00E9 la lunghezza dell''ID utente \u00E8 uguale a zero o maggiore della lunghezza massima consentita dal protocollo di rete.

08001.C.12=Non \u00E8 stato possibile stabilire una connessione perch\u00E9 la lunghezza della password \u00E8 uguale a zero o maggiore della lunghezza massima consentita dal protocollo di rete.

08001.C.13=Non \u00E8 stato possibile stabilire una connessione perch\u00E9 la lunghezza del nome esterno (EXTNAM) \u00E8 uguale a zero o maggiore della lunghezza massima consentita dal protocollo di rete.

08001.C.14=Non \u00E8 stato possibile stabilire una connessione perch\u00E9 la lunghezza del nome server (SRVNAM) \u00E8 uguale a zero o maggiore della lunghezza massima consentita dal protocollo di rete.

# Arguments:
#
#    {0} = propertyName
#
08001.C.1=Propriet\u00E0 Derby DataSource {0} richiesta non impostata.

# Arguments:
#
#    {0} = error
#    {1} = serverName
#    {2} = portNumber
#    {3} = messageText
#
08001.C.2={0}: Errore di connessione al server {1} sulla porta {2} con messaggio {3}.

# Arguments:
#
#    {0} = error
#
08001.C.3=SocketException: ''{0}''

# Arguments:
#
#    {0} = error
#
08001.C.4=Impossibile aprire il flusso sul socket: ''{0}''.

# Arguments:
#
#    {0} = number
#    {1} = number
#
08001.C.5=Lunghezza ID utente ({0}) fuori dall''intervallo da 1 a {1}.

# Arguments:
#
#    {0} = length
#    {1} = number
#
08001.C.6=Lunghezza password ({0}) fuori dall''intervallo da 1 a {1}.

08001.C.7=L''ID utente non pu\u00F2 essere nullo.

08001.C.8=La password non pu\u00F2 essere nulla.

# Arguments:
#
#    {0} = databaseName
#
08001.C.9=Non \u00E8 stato possibile stabilire una connessione perch\u00E9 la lunghezza del nome del database ''{0}'' supera la lunghezza massima consentita dal protocollo di rete.

08003=Nessuna connessione corrente.

08003.C.1=getConnection() non valido su una PooledConnection chiusa.

08003.C.2=Metodo Lob richiamato dopo la chiusura della connessione

08003.C.3=Connessione fisica di base non pi\u00F9 valida o chiusa.

# Arguments:
#
#    {0} = connectionName
#
08004=Connessione rifiutata: {0}

# Arguments:
#
#    {0} = reasonText
#
08004.C.1=Autenticazione della connessione non riuscita. Motivo: {0}.

# Arguments:
#
#    {0} = databaseName
#
08004.C.2=La connessione \u00E8 stata rifiutata perch\u00E9 il database {0} non \u00E8 stato trovato.

08004.C.3=Connessione al database rifiutata.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.4=L''utente ''{0}'' non pu\u00F2 chiudere il database ''{1}''. Solo il proprietario del database pu\u00F2 eseguire questa operazione.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.5=L''utente ''{0}'' non pu\u00F2 cifrare il database ''{1}''. Solo il proprietario del database pu\u00F2 eseguire questa operazione.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.6=L''utente ''{0}'' non pu\u00F2 eseguire l''aggiornamento del database ''{1}''. Solo il proprietario del database pu\u00F2 eseguire questa operazione.

# Arguments:
#
#    {0} = databaseName
#
08004.C.7=Connessione rifiutata al database ''{0}'' perch\u00E9 il database \u00E8 in modalit\u00E0 slave di replica.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.8=L''utente ''{0}'' non pu\u00F2 eseguire un''operazione di replica nel database ''{1}''. Solo il proprietario del database pu\u00F2 eseguire questa operazione.

# Arguments:
#
#    {0} = authorizationID
#    {1} = exceptionMsg
#
08004.C.9=Autorizzazione mancante per l''utente ''{0}'' per chiudere il sistema [{1}].

# Arguments:
#
#    {0} = databaseName
#    {1} = exceptionMsg
#
08004.C.10=Impossibile verificare le autorizzazioni di sistema per creare il database ''{0}'' [{1}].

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#    {2} = exceptionMsg
#
08004.C.11=Autorizzazione mancante per l''utente ''{0}'' per creare il database ''{1}'' [{2}].

08004.C.12=Autenticazione della connessione non riuscita. Le credenziali fornite non erano valide oppure il database utilizza uno schema di cifratura della password non compatibile con il rigido meccanismo di sicurezza basato sulla sostituzione delle password. Se l''errore si \u00E8 verificato dopo l''aggiornamento, fare riferimento alle note di rilascio relative a DERBY-4483 per le opzioni disponibili.

08004.C.13=Il nome utente o la password \u00E8 nullo o di lunghezza 0.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.14=L''utente ''{0}'' non pu\u00F2 decifrare il database ''{1}''. Solo il proprietario del database pu\u00F2 eseguire questa operazione.

# Arguments:
#
#    {0} = error
#
08006.C=Si \u00E8 verificato un errore del protocollo di rete e la connessione \u00E8 stata terminata: {0}

08006.C.1=Si \u00E8 verificato un errore durante la reimpostazione della connessione e la connessione \u00E8 stata terminata. Per i dettagli, vedere le eccezioni correlate.

# Arguments:
#
#    {0} = error
#
08006.C.2= SocketException: ''{0}''

# Arguments:
#
#    {0} = error
#
08006.C.3=\u00C8 stato rilevato un errore di comunicazione: {0}.

08006.C.4=Si \u00E8 verificato un errore durante la reimpostazione di una connessione rinviata e la connessione \u00E8 stata terminata. Per i dettagli, vedere le eccezioni correlate.

# Arguments:
#
#    {0} = number
#    {1} = number
#
08006.C.5=Dati insufficienti durante la lettura dalla rete - previsto un minimo di {0} byte e ricevuti solo {1} byte. La connessione \u00E8 stata terminata.

08006.C.6=Tentativo di materializzare in modo completo dati lob troppo grandi per la JVM. La connessione \u00E8 stata terminata.

08006.C.8=org.apache.derby.jdbc.EmbeddedDriver non registrato con JDBC Driver Manager

# Arguments:
#
#    {0} = databaseName
#
08006.D=Chiusura del database ''{0}''.

# Arguments:
#
#    {0} = databaseName
#
08006.D.1=Database ''{0}'' eliminato.

# Arguments:
#
#    {0} = featureName
#
0A000.S=Funzione non implementata: {0}.

# Arguments:
#
#    {0} = commandName
#
0A000.C.6=Il comando DRDA {0} non \u00E8 attualmente implementato. La connessione \u00E8 stata terminata.

0A000.S.1=Il metodo JDBC non \u00E8 stato ancora implementato.

# Arguments:
#
#    {0} = methodName
#
0A000.S.2=Il metodo JDBC {0} non \u00E8 supportato dal server. Aggiornare il server.

# Arguments:
#
#    {0} = propertyName
#
0A000.S.3=Propriet\u00E0 resultSetHoldability {0} non supportata

0A000.S.4=cancel() non supportato dal server.

# Arguments:
#
#    {0} = mechanismName
#
0A000.S.5=Meccanismo di sicurezza ''{0}'' non supportato.

# Arguments:
#
#    {0} = datatypeName
#
0A000.S.7=Tipo di dati ''{0}'' non supportato.

# Arguments:
#
#    {0} = roleName
#
0P000=Specifica di ruolo non valida, il ruolo \u00E8 inesistente: ''{0}''.

# Arguments:
#
#    {0} = roleName
#
0P000.S.1=Specifica di ruolo non valida, ruolo non concesso all''utente corrente o all''opzione PUBLIC: ''{0}''.

21000=La subquery scalare pu\u00F2 restituire solo una riga singola.

21000.S.1=Una riga della tabella di destinazione qualifica per pi\u00F9 azioni DELETE o UPDATE.

# Arguments:
#
#    {0} = dataType
#    {1} = dataValue
#    {2} = length
#
22001=\u00C8 stato riscontrato un errore di interruzione durante il tentativo di abbassare {0} ''{1}'' alla lunghezza di {2}.

# Arguments:
#
#    {0} = datatypeName
#
22003=Il valore risultante non \u00E8 compreso nell''intervallo per il tipo di dati {0}.

# Arguments:
#
#    {0} = year
#    {1} = year
#
22003.S.1=L''anno ({0}) supera il massimo ''{1}''.

22003.S.2=Il numero decimale pu\u00F2 contenere 31 cifre.

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
22003.S.3=Si \u00E8 verificato un overflow durante la conversione del tipo di dati numerici di ''{0}'' in {1}.

# Arguments:
#
#    {0} = number
#    {1} = datatypeName
#
22003.S.4=La lunghezza ({0}) supera la lunghezza massima ({1}) per il tipo di dati.

# Arguments:
#
#    {0} = typeName
#    {1} = typeName
#
22005.S.1=Impossibile convertire un valore di tipo ''{0}'' nel tipo ''{1}'': la codifica non \u00E8 supportata.

22005.S.2=Il convertitore del carattere richiesto non \u00E8 disponibile.

22005.S.3=Impossibile convertire la stringa Unicode nella stringa Ebcdic

# Arguments:
#
#    {0} = typeName
#    {1} = number
#    {2} = number
#
22005.S.4=Tipo JDBC non riconosciuto. Tipo: {0}, columnCount: {1}, columnIndex: {2}.

# Arguments:
#
#    {0} = parameterName
#
22005.S.5=Tipo JDBC non valido per il parametro {0}.

# Arguments:
#
#    {0} = datatypeName
#
22005.S.6=Tipo SQL Java {0} non riconosciuto.

22005.S.7=Impossibile convertire una stringa Unicode in una stringa UTF-8

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
22005=\u00C8 stato effettuato un tentativo per recuperare un valore dati di tipo ''{0}'' da uno di tipo ''{1}''.

22007.S.180=La rappresentazione della stringa di un valore data/ora non \u00E8 compresa nell''intervallo.

22007.S.181=La sintassi della rappresentazione della stringa di un valore data/ora non \u00E8 corretta.

# Arguments:
#
#    {0} = argument
#    {1} = functionName
#
22008.S=''{0}'' non \u00E8 un argomento valido per la funzione {1}.

# Arguments:
#
#    {0} = schemaName
#    {1} = sequenceName
#
2200H.S=Il generatore di sequenze ''{0}.{1}'' non esegue il nuovo ciclo. Non \u00E8 possibile ottenere altri valori da questo generatore di sequenze.

2200L=I valori assegnati alle colonne XML devono essere nodi Document in formato corretto.

# Arguments:
#
#    {0} = parserError
#
2200M=Documento XML non valido: {0}

# Arguments:
#
#    {0} = operatorName
#
2200V=Elemento di contesto non valido per l''operatore {0}; gli elementi di contesto devono essere nodi Document in formato corretto.

2200W=Errore di serializzazione XQuery: si \u00E8 tentato di serializzare uno o pi\u00F9 nodi Attribute di massimo livello.

22011=Il secondo o il terzo argomento della funzione SUBSTR non \u00E8 compreso nell''intervallo.

# Arguments:
#
#    {0} = offset
#    {1} = len
#    {2} = str
#
22011.S.1=L''intervallo di valori specificato per la sottostringa con offset {0} e len {1} \u00E8 stato superato per la stringa: {2}.

22012=Tentativo di dividere per zero.

# Arguments:
#
#    {0} = number
#
22013=Tentativo di ottenere la radice quadrata di un numero negativo, ''{0}''.

# Arguments:
#
#    {0} = searchString
#    {1} = fromString
#    {2} = startIndex
#
22014=La posizione iniziale di LOCATE non \u00E8 valida; \u00E8 necessario che sia un numero intero positivo. L''indice da cui iniziare la ricerca \u00E8 ''{2}''. La stringa di cui effettuare la ricerca \u00E8 ''{0}''. La stringa da cui effettuare la ricerca \u00E8 ''{1}''. 

# Arguments:
#
#    {0} = functionName
#    {1} = typeName
#    {2} = typeName
#    {3} = typeName
#
22015=La funzione ''{0}'' non \u00E8 consentita sul seguente insieme di tipi. Il primo operando \u00E8 di tipo ''{1}''. Il secondo operando \u00E8 di tipo ''{2}''. Il terzo operando (posizione iniziale) \u00E8 di tipo ''{3}''.

# Arguments:
#
#    {0} = typeName
#
22018=Formato stringa di caratteri non valido per il tipo {0}.

# Arguments:
#
#    {0} = sequenceName
#
22019=Sequenza di escape non valida, ''{0}''. La stringa di escape deve essere esattamente un carattere. Non pu\u00F2 essere vuota o contenere pi\u00F9 di un carattere.

# Arguments:
#
#    {0} = string
#
22020=Stringa ''{0}'' risultante da trim non valida. La stringa deve contenere esattamente un carattere o un valore NULL. Non pu\u00F2 contenere pi\u00F9 di un carattere.

22025=Il carattere di escape deve essere seguito da un carattere di escape, ''_'' oppure ''%''. Non pu\u00F2 essere seguito da altri caratteri o trovarsi alla fine del pattern.

22027=La funzione integrata TRIM() consente di eliminare un solo carattere. Le funzioni integrate LTRIM() e RTRIM() consentono di eliminare pi\u00F9 caratteri.

# Arguments:
#
#    {0} = number
#
22028=La stringa supera la lunghezza massima di {0}.

22501=Una clausola ESCAPE di NULL restituisce risultati non definiti e non \u00E8 consentita.

2201X=Conteggio righe non valido per OFFSET, il valore consentito \u00E8 >= 0.

2201W=Il conteggio delle righe per FIRST/NEXT deve essere >= 1 e il conteggio delle righe per LIMIT deve essere >= 0.

# Arguments:
#
#    {0} = string
#
2201Z=Valore NULL non consentito per l''argomento {0}.

# Arguments:
#
#    {0} = columnName
#
23502=La colonna ''{0}'' non pu\u00F2 accettare un valore NULL.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = statementType
#    {3} = keyName
#
23503={2} sulla tabella ''{1}'' ha causato una violazione del vincolo di chiave esterna ''{0}'' per la chiave {3}. L''istruzione \u00E8 stata sottoposta a rollback.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#
23505=L''istruzione \u00E8 stata interrotta perch\u00E9 avrebbe provocato un valore di chiave duplicata in un vincolo di chiave univoca o primaria o in un indice univoco identificato da ''{0}'' definito su ''{1}''.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#
23506.T.1=La transazione \u00E8 stata interrotta a causa di una violazione vincolo differita: valore duplicato in un vincolo UNIQUE KEY o PRIMARY KEY identificato da ''{0}'' definito su ''{1}''.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#
23507.S.1=Violazione vincolo differita: valore duplicato in un vincolo UNIQUE KEY o PRIMARY KEY identificato da ''{0}'' definito su ''{1}''.

# Arguments:
#
#    {0} = tableName
#    {1} = constraintName
#
23513=Il vincolo di controllo ''{1}'' \u00E8 stato violato durante l''esecuzione di INSERT o UPDATE sulla tabella ''{0}''.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#    {2} = constraintText
#
23514.T.1=La transazione \u00E8 stata interrotta a causa di una violazione vincolo differita: controllare il vincolo identificato da ''{0}'' definito su ''{1}'' come ''{2}''.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#    {2} = constraintText
#
23515.S.1=Violazione vincolo differita: controllare il vincolo identificato da ''{0}'' definito su ''{1}'' come ''{2}''.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#    {2} = indexOrConstraintName
#    {3} = tableName
#    {4} = keyName
#
23516.T.1=La transazione \u00E8 stata interrotta a causa di una violazione vincolo differita: chiave esterna ''{0}'' definita su ''{1}'' con riferimento al vincolo ''{2}'' definito su {3}, chiave ''{4}''.

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#    {2} = indexOrConstraintName
#    {3} = tableName
#    {4} = keyName
#
23517.S.1=Violazione vincolo differita: vincolo FOREIGN KEY ''{0}'' definito su ''{1}'' con riferimento al vincolo ''{2}'' definito su {3}, chiave ''{4}''.

24000=Stato cursore non valido - nessuna riga corrente.

24501.S=Il cursore identificato non \u00E8 aperto.

25001=Impossibile chiudere una connessione se una transazione \u00E8 ancora attiva.

25001.S.1=Stato transazione non valido: transazione SQL attiva.

25501=Impossibile impostare la propriet\u00E0 di sola lettura della connessione in una transazione attiva.

25502=Modifica dati SQL non consentita per una connessione, un utente o un database di sola lettura.

25503=DDL non consentito per una connessione, un utente o un database di sola lettura.

25505=Un utente con autorizzazione di sola lettura o un utente in un database di sola lettura non pu\u00F2 disabilitare la modalit\u00E0 di sola lettura su una connessione.

# Arguments:
#
#    {0} = authorizationID
#
28502=Il nome utente ''{0}'' non \u00E8 valido. 

2D521.S.1=setAutoCommit(true) non valido durante la transazione globale.

2D521.S.2=Commit o Rollback non valido per l''ambiente di esecuzione dell''applicazione. 

# Arguments:
#
#    {0} = exception
#
38000=\u00C8 stata restituita l''eccezione ''{0}'' durante la valutazione di un''espressione.

38001=La routine esterna non pu\u00F2 eseguire istruzioni SQL.

38002=La routine ha tentato di modificare i dati, ma non era definita come MODIFIES SQL DATA.

38004=La routine ha tentato di leggere i dati, ma non era definita come READS SQL DATA.

# Arguments:
#
#    {0} = type
#
39004=Non \u00E8 possibile passare un valore NULL a un metodo che utilizza un parametro di tipo primitivo ''{0}''.

# Arguments:
#
#    {0} = savepointName
#
3B001.S=SAVEPOINT, {0} non esistente o non attivo nella transazione corrente.

3B002.S=\u00C8 stato raggiunto il numero massimo di savepoint. 

3B501.S=SAVEPOINT con il nome passato gi\u00E0 esistente nella transazione corrente.

3B502.S=\u00C8 stato specificato Release o Rollback per un savepoint che non esiste.

# Arguments:
#
#    {0} = lockCycle
#    {1} = transactionID
#
40001=Impossibile ottenere un blocco a causa di un deadlock, il ciclo di blocchi e waiter \u00E8:\n{0}. La vittima selezionata \u00E8 XID: {1}.

40XC0=Istruzione inattiva. Ci\u00F2 pu\u00F2 essere causato dal rilevamento di un errore di severit\u00E0 della transazione all''interno di tale istruzione.

40XD0=Il contenitore \u00E8 stato chiuso.

40XD1=Il contenitore \u00E8 stato aperto in modalit\u00E0 di sola lettura.

# Arguments:
#
#    {0} = containerName
#
40XD2=Impossibile aprire il contenitore {0}; il contenitore \u00E8 stato eliminato o non esiste.

40XL1=Impossibile ottenere un blocco nel tempo richiesto

# Arguments:
#
#    {0} = tableDump
#
40XL1.T.1=Impossibile ottenere un blocco nel tempo richiesto. Il dump lockTable \u00E8: {0}

40XL2=Auto-deadlock.

40XT0=\u00C8 stato identificato un errore interno dal modulo RawStore.

40XT1=Un''eccezione \u00E8 stata restituita durante l''operazione di commit della transazione.

40XT2=\u00C8 stata restituita un''eccezione durante l''operazione di rollback di un SAVEPOINT.

40XT4=\u00C8 stato effettuato un tentativo di chiudere una transazione ancora attiva. La transazione \u00E8 stata interrotta.

40XT5=Eccezione restituita durante una transazione interna.

40XT6=Il database si trova in stato inattivo, impossibile attivare la transazione. Attendere l''uscita dallo stato inattivo.

40XT7=Operazione non supportata in una transazione interna.

# Arguments:
#
#    {0} = internalTransactionState
#
40XT8=Il modulo RawStore ha identificato un errore interno. Dettagli dello stato interno della transazione: {0}

42000=Errore di sintassi o violazione della regola di accesso; per i dettagli, vedere ulteriori errori.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = schemaNamet
#    {3} = tableName
#
42500=L''utente ''{0}'' non dispone dell''autorizzazione {1} sulla tabella ''{2}''.''{3}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = schemaNamet
#    {3} = tableName
#
42501=L''utente ''{0}'' non dispone dell''autorizzazione {1} sulla tabella ''{2}''.''{3}'' per la concessione.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = columnName
#    {3} = schemaName
#    {4} = tableName
#
42502=L''utente ''{0}'' non dispone dell''autorizzazione {1} sulla colonna ''{2}'' della tabella ''{3}''.''{4}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = columnName
#    {3} = schemaName
#    {4} = tableName
#
42503=L''utente ''{0}'' non dispone dell''autorizzazione {1} sulla colonna ''{2}'' della tabella ''{3}''.''{4}'' per la concessione.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = objectName
#    {3} = schemaName
#    {4} = tableName
#
42504=L''utente ''{0}'' non dispone dell''autorizzazione {1} su {2} ''{3}''.''{4}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = objectName
#    {3} = schemaName
#    {4} = tableName
#
42505=L''utente ''{0}'' non dispone dell''autorizzazione {1} su {2} ''{3}''.''{4}'' per la concessione.

# Arguments:
#
#    {0} = authorizationID
#    {1} = objectName
#    {2} = schemaName
#    {3} = tableName
#
42506=L''utente ''{0}'' non \u00E8 il proprietario di {1} ''{2}''.''{3}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = schemaName
#
42507=L''utente ''{0}'' non pu\u00F2 eseguire l''operazione nello schema ''{1}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = schemaName
#
42508=L''utente ''{0}'' non pu\u00F2 creare lo schema ''{1}''. Solo il proprietario del database pu\u00F2 eseguire questa istruzione.

# Arguments:
#
#    {0} = objectName
#
42509=L''operazione di concessione o revoca specificata non \u00E8 consentita sull''oggetto ''{0}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionName
#    {2} = schemaName
#    {3} = objectName
#
4250A=L''utente ''{0}'' non dispone dell''autorizzazione {1} sull''oggetto ''{2}''.''{3}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
4250B=Propriet\u00E0 di autorizzazione database ''{0}={1}'' non valida.

# Arguments:
#
#    {0} = authorizationID
#
4250C=L''utente o gli utenti ''{0}'' non devono essere inclusi in entrambe le liste di autorizzazioni di sola lettura e di accesso completo.

# Arguments:
#
#    {0} = listName
#    {1} = authorizationID
#
4250D=Utente ripetuto o utenti ripetuti ''{1}'' nella lista di accesso ''{0}'';

# Arguments:
#
#    {0} = authorizationID
#
4250E=Errore interno: ID {0} non valido nella lista delle autorizzazioni delle istruzioni.

# Arguments:
#
#    {0} = sqlText
#
4251A=Solo il proprietario del database pu\u00F2 eseguire l''istruzione {0}.

4251B=Il valore PUBLIC \u00E8 riservato e non pu\u00F2 essere utilizzato come identificativo di utenti o nome di ruolo.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
4251C=Il ruolo {0} non pu\u00F2 essere concesso a {1} perch\u00E9 creerebbe una circolarit\u00E0.

4251D=Solo il proprietario del database pu\u00F2 eseguire questa operazione.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
4251E=Nessuno pu\u00F2 visualizzare la colonna ''{0}''.''{1}''.

4251F=Non \u00E8 possibile eliminare le credenziali del proprietario del database.

4251G=Impostare derby.authentication.builtin.algorithm su un algoritmo digest dei messaggi valido. Lo schema di autenticazione corrente \u00E8 troppo debole per essere usato dall''autenticazione NATIVE.

4251H=Specifica di autenticazione NATIVE non valida. Impostare derby.authentication.provider su un valore del form NATIVE:$credentialsDB o NATIVE:$credentialsDB:LOCAL (a livello di sistema).

# Arguments:
#
#    {0} = databaseName
#
4251I=Non \u00E8 possibile eseguire l''autenticazione perch\u00E9 il database ''{0}'' delle credenziali \u00E8 inesistente.

# Arguments:
#
#    {0} = propertyName
#
4251J=Il valore della propriet\u00E0 ''{0}'' \u00E8 formattato in modo errato.

4251K=Le prime credenziali create devono essere quelle del DBO.

# Arguments:
#
#    {0} = dbName
#
4251L=La propriet\u00E0 derby.authentication.provider specifica ''{0}'' come nome del database delle credenziali. Questo non \u00E8 un nome valido per un database.

# Arguments:
#
#    {0} = columnName
#
42601=In un''istruzione ALTER TABLE, la colonna ''{0}'' \u00E8 stata specificata come NOT NULL e la clausola DEFAULT non \u00E8 stata specificata o \u00E8 stata specificata come DEFAULT NULL.

42601.S.372=L''istruzione ALTER TABLE non pu\u00F2 aggiungere una colonna IDENTITY a una tabella.

# Arguments:
#
#    {0} = functionName
#
42605=Il numero di argomenti per la funzione ''{0}'' \u00E8 errato.

# Arguments:
#
#    {0} = number
#
42606=\u00C8 stata rilevata una costante esadecimale non valida che inizia con ''{0}''.

42610=Tutti gli argomenti della funzione COALESCE/VALUE non possono essere parametri. La funzione richiede almeno un argomento che non sia un parametro.

# Arguments:
#
#    {0} = dataType
#
42611=L''attributo relativo alla lunghezza, alla precisione o alla scala per la colonna o il mapping del tipo ''{0}'' non \u00E8 valido. 

# Arguments:
#
#    {0} = clause
#
42613=Sono presenti pi\u00F9 parole chiave o parole chiave in conflitto riguardanti la clausola ''{0}''.

# Arguments:
#
#    {0} = columnName
#
42621=Un vincolo di controllo o una colonna generata definita con ''{0}'' non sono validi.

# Arguments:
#
#    {0} = name
#    {1} = number
#
42622=Il nome ''{0}'' \u00E8 troppo lungo. La lunghezza massima \u00E8 ''{1}''.

# Arguments:
#
#    {0} = name
#    {1} = context
#
42734=Il nome ''{0}'' specificato nel contesto ''{1}'' non \u00E8 univoco.

42802=Il numero dei valori assegnati non corrisponde al numero delle colonne interessate o specificate.

# Arguments:
#
#    {0} = columnName
#
42803=Un''espressione contenente la colonna ''{0}'' viene visualizzata nella lista SELECT e non fa parte di una clausola GROUP BY.

# Arguments:
#
#    {0} = sqlText
#
42815.S.713=Il valore di sostituzione per ''{0}'' non \u00E8 valido.

# Arguments:
#
#    {0} = dataType
#    {1} = dataType
#
42815.S.171=Il tipo di dati, la lunghezza o il valore degli argomenti ''{0}'' e ''{1}'' sono incompatibili.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42818=I confronti tra ''{0}'' e ''{1}'' non sono supportati. I tipi devono essere confrontabili. I tipi di stringa devono anche disporre di un ordinamento corrispondente. Se l''ordinamento non corrisponde, una soluzione possibile consiste nel forzare l''utilizzo dell''ordinamento predefinito per gli operandi (ad esempio, SELECT tablename FROM sys.systables WHERE CAST(tablename AS VARCHAR(128)) = ''T1'')

# Arguments:
#
#    {0} = string
#
42820=Il valore a virgola mobile ''{0}'' contiene pi\u00F9 di 30 caratteri.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42821=Le colonne di tipo ''{0}'' non possono contenere valori di tipo ''{1}''. 

42824=Un operando di LIKE non \u00E8 una stringa oppure il primo operando non \u00E8 una colonna.

# Arguments:
#
#    {0} = columnName
#
42831=''{0}'' non pu\u00F2 essere una colonna di una chiave primaria o di una chiave univoca perch\u00E9 pu\u00F2 contenere valori nulli.

# Arguments:
#
#    {0} = columnName
#
42831.S.1=''{0}'' non pu\u00F2 essere una colonna di una chiave primaria poich\u00E9 pu\u00F2 contenere valori nulli.

# Arguments:
#
#    {0} = key
#
42834=Impossibile specificare SET NULL poich\u00E9 FOREIGN KEY ''{0}'' non pu\u00F2 contenere valori nulli.  

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42837=Gli attributi specificati da ALTER TABLE ''{0}'' per la colonna ''{1}'' non sono compatibili con la colonna esistente.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42846=Impossibile convertire i tipi ''{0}'' in ''{1}''.

# Arguments:
#
#    {0} = columnName
#
42877=Un nome di colonna qualificato ''{0}'' non \u00E8 consentito nella clausola ORDER BY.

42878=La clausola ORDER BY di un''istruzione SELECT UNION supporta solo riferimenti di colonna non qualificati e numeri di posizione delle colonne. Altre espressioni non sono attualmente supportate.

# Arguments:
#
#    {0} = columnName
#
42879=La clausola ORDER BY non pu\u00F2 contenere la colonna ''{0}'' poich\u00E9 la query utilizza la clausola DISTINCT e la colonna in oggetto non appare nel risultato della query.

4287A=La clausola ORDER BY non pu\u00F2 specificare un''espressione poich\u00E9 la query utilizza la clausola DISTINCT.

4287B=In questo contesto la clausola ORDER BY pu\u00F2 specificare solo un numero di colonna.

# Arguments:
#
#    {0} = routineName
#    {1} = type
#
42884=Non \u00E8 stata trovata nessuna routine autorizzata denominata ''{0}'' di tipo ''{1}'' contenente argomenti compatibili.

# Arguments:
#
#    {0} = parameterMode
#    {1} = parameterName
#
42886=Il parametro ''{0}'' ''{1}'' richiede un indicatore di parametro ''?''.

# Arguments:
#
#    {0} = columnName
#
42894=Il valore DEFAULT o il valore di attributo IDENTITY non \u00E8 valido per la colonna ''{0}''.

428C1=In una tabella \u00E8 consentita una sola colonna di identit\u00E0.

428EK=Il qualificatore per un nome di tabella temporanea globale dichiarata deve essere SESSION.

42903=Uso non valido di una funzione di aggregazione.

42908=L''istruzione CREATE VIEW non include una lista di colonne.

42909=L''istruzione CREATE TABLE non include una lista di colonne.

# Arguments:
#
#    {0} = key
#    {1} = detailedReason
#
42915=La chiave esterna ''{0}'' non \u00E8 valida per il motivo seguente: ''{1}''. 

# Arguments:
#
#    {0} = synonym2
#    {1} = synonym1
#
42916=Il sinonimo ''{0}'' non pu\u00F2 essere creato per ''{1}'' in quanto il risultato sarebbe una catena di sinonimi circolare.

# Arguments:
#
#    {0} = schemaNamet
#
42939=Non \u00E8 possibile creare un oggetto con il nome di schema ''{0}''.

# Arguments:
#
#    {0} = authorizationID
#
4293A=Non \u00E8 possibile creare un ruolo con il nome ''{0}'', il prefisso SYS \u00E8 riservato.

# Arguments:
#
#    {0} = columnName
#
42962=Tipo di colonna lungo o parametro ''{0}'' non consentito nelle tabelle temporanee globali dichiarate o nelle definizioni di procedura. 

42995=La funzione richiesta non si applica alle tabelle temporanee globali.

# Arguments:
#
#    {0} = error
#
42X01=Errore di sintassi: {0}.

# Arguments:
#
#    {0} = parserException
#
42X02={0}.

# Arguments:
#
#    {0} = columnName
#
42X03=Il nome di colonna ''{0}'' si trova in pi\u00F9 di una tabella presente nella lista FROM.

# Arguments:
#
#    {0} = columnName
#    {1} = columnName
#
42X04=La colonna ''{0}'' non si trova in nessuna tabella della lista FROM oppure compare in una specifica di join ed \u00E8 esterna all''ambito di tale specifica oppure compare in una clausola HAVING e non \u00E8 presente nella lista GROUP BY. Se si tratta di un''istruzione CREATE o ALTER TABLE, ''{0}'' non \u00E8 una colonna della tabella di destinazione.

# Arguments:
#
#    {0} = objectName
#
42X05=Tabella/Vista ''{0}'' inesistente.

# Arguments:
#
#    {0} = tableName
#
42X06=Sono state specificate troppe colonne di risultati per la tabella ''{0}''.

42X07=Il carattere nullo \u00E8 consentito solo in una clausola VALUES all''interno di un''istruzione INSERT.

# Arguments:
#
#    {0} = className
#    {1} = constructorName
#
42X08=Il costruttore della classe ''{0}'' non pu\u00F2 essere utilizzato come una tabella virtuale esterna se la classe non implementa ''{1}''. 

# Arguments:
#
#    {0} = tableName
#
42X09=Il nome di tabella o alias ''{0}'' \u00E8 stato utilizzato pi\u00F9 di una volta nella lista FROM.

# Arguments:
#
#    {0} = tableName
#
42X10=''{0}'' non \u00E8 un nome di tabella esposto nell''ambito in cui viene visualizzato.

# Arguments:
#
#    {0} = columnName
#
42X12=Il nome di colonna ''{0}'' compare pi\u00F9 di una volta nell''istruzione CREATE TABLE.  

# Arguments:
#
#    {0} = columnName
#
42X13=Il nome di colonna ''{0}'' compare pi\u00F9 di una volta nella lista di colonne di un''istruzione INSERT. 

# Arguments:
#
#    {0} = columnName
#    {1} = tableOrVTIName
#
42X14=''{0}'' non \u00E8 una colonna nella tabella o VTI ''{1}''.

# Arguments:
#
#    {0} = columnName
#
42X15=Il nome di colonna ''{0}'' compare in un''istruzione senza una lista FROM.

# Arguments:
#
#    {0} = columnName
#
42X16=Il nome di colonna ''{0}'' compare pi\u00F9 volte nella clausola SET di un''istruzione UPDATE.

# Arguments:
#
#    {0} = joinOrder
#
42X17=Il valore ''{0}'' non \u00E8 valido come specifica joinOrder nella lista delle propriet\u00E0 di una clausola FROM. Solo i valori FIXED e UNFIXED sono validi.  

# Arguments:
#
#    {0} = dataType
#
42X19.S.1=La clausola WHERE, WHEN o HAVING oppure la definizione CHECK CONSTRAINT \u00E8 un''espressione ''{0}''. Deve essere un''espressione BOOLEAN.

42X19.S.2=La clausola WHERE o HAVING oppure la definizione CHECK CONSTRAINT \u00E8 un''''espressione di parametro senza tipo. Deve essere un''''espressione BOOLEAN.

42X20=Errore di sintassi, previsto valore di numero intero.

# Arguments:
#
#    {0} = cursorName
#
42X23=Il cursore {0} non \u00E8 aggiornabile.

# Arguments:
#
#    {0} = columnName
#
42X24=La colonna {0} \u00E8 referenziata nella clausola HAVING ma non \u00E8 inclusa nella lista GROUP BY.

# Arguments:
#
#    {0} = functionName
#    {1} = 1
#
42X25=La funzione ''{0}'' non \u00E8 consentita sul tipo ''{1}''.

# Arguments:
#
#    {0} = className
#    {1} = columnName
#
42X26=La classe ''{0}'' per la colonna ''{1}'' \u00E8 inesistente o inaccessibile. Ci\u00F2 pu\u00F2 verificarsi se la classe non \u00E8 pubblica.

# Arguments:
#
#    {0} = tableName
#    {1} = cursorName
#
42X28=La tabella di eliminazione ''{0}'' non \u00E8 la destinazione del cursore ''{1}''.

# Arguments:
#
#    {0} = tableName
#    {1} = cursorName
#
42X29=La tabella di aggiornamento ''{0}'' non \u00E8 la destinazione del cursore ''{1}''.

# Arguments:
#
#    {0} = cursorName
#
42X30=Cursore ''{0}'' non trovato. Verificare che il commit automatico sia inattivo.

# Arguments:
#
#    {0} = columnName
#    {1} = cursorName
#
42X31=La colonna ''{0}'' non si trova nella lista FOR UPDATE del cursore ''{1}''.

# Arguments:
#
#    {0} = tableName
#
42X32=Il numero di colonne presenti nella lista di colonne derivate deve corrispondere al numero di colonne presenti nella tabella ''{0}''.

# Arguments:
#
#    {0} = columnName
#
42X33=La lista di colonne derivate contiene un nome colonna duplicato ''{0}''.

42X34=Esiste un parametro ? nella lista di selezione. Ci\u00F2 non \u00E8 consentito.

# Arguments:
#
#    {0} = operatorName
#
42X35=Non \u00E8 consentito che entrambi gli operandi di ''{0}'' siano parametri ?.

# Arguments:
#
#    {0} = operatorName
#
42X36=L''operatore ''{0}'' non pu\u00F2 utilizzare un parametro ? come operando.

# Arguments:
#
#    {0} = operatorName
#    {1} = type
#
42X37=Operatore unario ''{0}'' non consentito sul tipo ''{1}''.

42X38=''SELECT *'' \u00E8 consentito solo nelle subquery EXISTS e NOT EXISTS.

42X39=La subquery pu\u00F2 restituire solo una colonna singola.

42X40=Un''istruzione NOT contiene un operando non booleano. Il risultato dell''operando di NOT deve essere TRUE, FALSE o UNKNOWN. 

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
42X41=Nella clausola Properties di una lista FROM, la propriet\u00E0 ''{0}'' non \u00E8 valida (la propriet\u00E0 era stata impostata su ''{1}''). 

# Arguments:
#
#    {0} = columnName
#
42X42=Nome correlazione non consentito per la colonna ''{0}'' perch\u00E9 parte della lista FOR UPDATE.

# Arguments:
#
#    {0} = className
#
42X43=ResultSetMetaData restituito per classe/oggetto ''{0}'' era nullo. Per utilizzare questa classe come una tabella virtuale esterna, \u00E8 necessario che ResultSetMetaData non sia nullo. 

# Arguments:
#
#    {0} = number
#
42X44=Lunghezza ''{0}'' non valida come specifica di colonna.

# Arguments:
#
#    {0} = dataType
#    {1} = argumentNumber
#    {2} = operatorName
#
42X45={0} non \u00E8 un tipo valido per l''argomento numero {1} di {2}.

# Arguments:
#
#    {0} = functionName
#
42X46=Esistono pi\u00F9 funzioni denominate ''{0}''. Utilizzare la firma completa o il nome specifico.

# Arguments:
#
#    {0} = procedureName
#
42X47=Esistono pi\u00F9 procedure denominate ''{0}''. Utilizzare la firma completa o il nome specifico.

# Arguments:
#
#    {0} = dataType
#    {1} = number
#
42X48=Il valore ''{1}'' non rappresenta una precisione valida per {0}.

# Arguments:
#
#    {0} = invalidNumber
#
42X49=Il valore ''{0}'' non \u00E8 un valore di numero intero valido.

# Arguments:
#
#    {0} = className
#    {1} = methodName
#    {2} = parameterTypes
#
42X50=Non \u00E8 stato trovato nessun metodo corrispondente alla chiamata del metodo {0}.{1}({2}), sono state tentate tutte le combinazioni di tipi oggetti e tipi primitivi e qualsiasi conversione di tipo possibile per tutti i parametri che la chiamata al metodo pu\u00F2 assumere. \u00C8 possibile che il metodo esista ma che non sia pubblico e/o statico oppure che i tipi di parametri non siano convertibili in richiami di metodi.

# Arguments:
#
#    {0} = className
#
42X51=La classe ''{0}'' \u00E8 inesistente o non \u00E8 accessibile. Ci\u00F2 pu\u00F2 verificarsi se la classe non \u00E8 pubblica.

# Arguments:
#
#    {0} = methodName
#    {1} = type
#
42X52=La chiamata al metodo (''{0}'') tramite un destinatario di tipo primitivo Java ''{1}'' non \u00E8 consentita.

# Arguments:
#
#    {0} = type
#
42X53=Il predicato LIKE pu\u00F2 avere solo operandi ''CHAR'' o ''VARCHAR''. Il tipo ''{0}'' non \u00E8 consentito.

# Arguments:
#
#    {0} = methodName
#
42X54=Il metodo Java ''{0}'' ha come destinatario un parametro ?. Ci\u00F2 non \u00E8 consentito.

# Arguments:
#
#    {0} = tableName
#    {1} = tableName
#
42X55=Il nome tabella ''{1}'' deve essere uguale a ''{0}''.

# Arguments:
#
#    {0} = viewName
#
42X56=Il numero di colonne presenti nella lista delle colonne della vista non corrisponde al numero di colonne presenti nell''espressione della query di base nella definizione della vista per ''{0}''.

# Arguments:
#
#    {0} = tableName
#    {1} = number
#
42X57=getColumnCount() per la tabella virtuale esterna ''{0}'' ha restituito un valore ''{1}'' non valido. I valori validi sono maggiori o uguali a 1. 

# Arguments:
#
#    {0} = tableName
#
42X58=Il numero di colonne presenti sul lato destro e sinistro di {0} deve essere uguale.

42X59=Il numero di colonne presenti in ogni costruttore VALUES deve essere uguale.

# Arguments:
#
#    {0} = insertMode
#    {1} = tableName
#
42X60=Valore ''{0}'' non valido per la propriet\u00E0 insertMode specificata per la tabella ''{1}''.

# Arguments:
#
#    {0} = dataType
#    {1} = dataType
#    {2} = sqlOperator
#
42X61=I tipi ''{0}'' e ''{1}'' non sono compatibili con {2}.

# Arguments:
#
#    {0} = sqlText
#    {1} = schemaName
#
42X62=''{0}'' non \u00E8 consentito nello schema ''{1}''.

42X63=La clausola USING non ha restituito alcun risultato. Impossibile impostare alcun parametro. 

# Arguments:
#
#    {0} = propertyValue
#
42X64=Nella lista Propriet\u00E0, il valore non valido ''{0}'' \u00E8 stato specificato per la propriet\u00E0 useStatistics. Gli unici valori validi sono TRUE o FALSE. 

# Arguments:
#
#    {0} = index
#
42X65=L''indice ''{0}'' non esiste.

# Arguments:
#
#    {0} = columnName
#
42X66=Il nome colonna ''{0}'' compare pi\u00F9 di una volta nell''istruzione CREATE INDEX.

# Arguments:
#
#    {0} = fieldName
#    {1} = className
#
42X68=Non \u00E8 stato trovato alcun campo ''{0}'' appartenente alla classe ''{1}''. \u00C8 possibile che il campo esista ma non sia pubblico oppure che la classe non esista o non sia pubblica.

# Arguments:
#
#    {0} = fieldName
#    {1} = type
#
42X69=Non \u00E8 consentito fare riferimento a un campo (''{0}'') tramite un''espressione di riferimento del tipo primitivo Java ''{1}''.

# Arguments:
#
#    {0} = tableName
#
42X70=Il numero di colonne nella lista di colonne della tabella non corrisponde al numero di colonne dell''espressione della query di base nella definizione di tabella per ''{0}''.

# Arguments:
#
#    {0} = datatypeName
#    {1} = columnName
#
42X71=Tipo di dati non valido ''{0}'' per la colonna ''{1}''.

# Arguments:
#
#    {0} = fieldName
#    {1} = className
#
42X72=Non \u00E8 stato trovato alcun campo statico ''{0}'' appartenente alla classe ''{1}''. \u00C8 possibile che il campo esista ma non sia pubblico e/o statico oppure che la classe non esista o non sia pubblica.  

# Arguments:
#
#    {0} = className
#    {1} = methodName
#    {2} = parameterTypes
#
42X73=Risoluzione del metodo per la firma {0}.{1}({2}) era ambigua. Il metodo specifico esistente non \u00E8 unico.

42X74=Sintassi dell''istruzione CALL non valida.

# Arguments:
#
#    {0} = className
#    {1} = parameterTypes
#
42X75=Non \u00E8 stato trovato nessun costruttore con firma {0}({1}). \u00C8 possibile che i tipi di parametri non siano convertibili in richiami a metodi.

# Arguments:
#
#    {0} = columnName
#
42X76=Almeno una colonna, ''{0}'', nella chiave primaria aggiunta \u00E8 annullabile. Tutte le colonne presenti in una chiave primaria non devono essere annullabili.

# Arguments:
#
#    {0} = columnPosition
#
42X77=La posizione della colonna ''{0}'' non \u00E8 compresa nell''intervallo per l''espressione della query.

# Arguments:
#
#    {0} = columnName
#
42X78=La colonna ''{0}'' non \u00E8 presente nel risultato dell''espressione della query.

# Arguments:
#
#    {0} = columnName
#
42X79=Il nome colonna ''{0}'' compare pi\u00F9 di una volta nel risultato dell''espressione della query.

42X80=La clausola VALUES deve contenere almeno un elemento. Gli elementi vuoti non sono consentiti. 

42X81=Un''espressione di query deve restituire almeno una colonna.

42X82=La clausola USING ha restituito pi\u00F9 di una riga. Sono consentiti solo ResultSet di righe singole.

# Arguments:
#
#    {0} = index
#    {1} = constraintName
#
42X84=L''indice ''{0}'' \u00E8 stato creato per rafforzare il vincolo ''{1}''. \u00C8 possibile eliminarlo solo eliminando il vincolo.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42X85=Il vincolo ''{0}'' deve essere contenuto nello stesso schema della tabella ''{1}''.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42X86=ALTER TABLE non riuscito. Non esiste alcun vincolo ''{0}'' sulla tabella ''{1}''. 

42X87=Almeno un''espressione di risultato (THEN o ELSE) dell''espressione CASE deve contenere un tipo conosciuto.

42X88=Un''espressione condizionale ha un operando non booleano. Il risultato dell''operando di un''espressione condizionale deve essere TRUE, FALSE o UNKNOWN.  

# Arguments:
#
#    {0} = type
#    {1} = type
#
42X89=I tipi ''{0}'' e ''{1}'' non sono tipi compatibili. Nessun tipo \u00E8 assegnabile all''altro tipo.  

# Arguments:
#
#    {0} = tableName
#
42X90=Pi\u00F9 di un vincolo della chiave primaria specificato per la tabella ''{0}''.

# Arguments:
#
#    {0} = constraintName
#
42X91=Il nome vincolo ''{0}'' compare pi\u00F9 di una volta nell''istruzione CREATE TABLE. 

# Arguments:
#
#    {0} = columnName
#
42X92=Il nome colonna ''{0}'' compare pi\u00F9 di una volta nella lista di colonne del vincolo.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42X93=La tabella ''{0}'' contiene una definizione di vincolo con la colonna ''{1}'', che non \u00E8 presente nella tabella.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = objectName
#
42X94={0} ''{1}'' inesistente.

# Arguments:
#
#    {0} = fileName
#
42X96=Il classpath database contiene un file jar sconosciuto ''{0}''.

42X97=Caratteristiche vincolo in conflitto per il vincolo.

42X98=I parametri non sono consentiti in una definizione VIEW.

42X99=I parametri non sono consentiti in una definizione TABLE.

# Arguments:
#
#    {0} = columnName
#    {1} = datatypeName
#
42XA0=Il tipo di dati della clausola di generazione per la colonna ''{0}'' \u00E8 ''{1}'' e non pu\u00F2 essere assegnato al tipo di dati dichiarato per la colonna.

# Arguments:
#
#    {0} = columnName
#
42XA1=La clausola di generazione per la colonna ''{0}'' contiene un''aggregazione. Ci\u00F2 non \u00E8 consentito.

# Arguments:
#
#    {0} = sqlObjectName
#
42XA2=Impossibile utilizzare ''{0}'' in una clausola di generazione perch\u00E9 potrebbe restituire risultati inaffidabili.

# Arguments:
#
#    {0} = columnName
#
42XA3=Non \u00E8 possibile sostituire il valore della colonna generata ''{0}''.

# Arguments:
#
#    {0} = columnName
#
42XA4=La clausola di generazione per la colonna ''{0}'' fa riferimento ad altre colonne generate. Ci\u00F2 non \u00E8 consentito.

# Arguments:
#
#    {0} = routineName
#
42XA5=La routine ''{0}'' potrebbe eseguire un''istruzione SQL, pertanto non pu\u00F2 comparire in questo contesto.

# Arguments:
#
#    {0} = columnName
#
42XA6=''{0}'' \u00E8 una colonna generata. Non pu\u00F2 far parte di una chiave esterna la cui azione di riferimento per DELETE \u00E8 SET NULL o SET DEFAULT oppure la cui azione di riferimento per UPDATE \u00E8 CASCADE.

# Arguments:
#
#    {0} = columnName
#
42XA7=''{0}'' \u00E8 una colonna generata o di identit\u00E0. Impossibile modificarne il valore predefinito.

# Arguments:
#
#    {0} = columnName
#    {1} = columnName
#
42XA8=Non \u00E8 possibile rinominare ''{0}'' poich\u00E9 \u00E8 utilizzata come riferimento dalla clausola di generazione della colonna ''{1}''.

# Arguments:
#
#    {0} = columnName
#
42XA9=La colonna ''{0}'' richiede un tipo di dati esplicito. Il tipo di dati pu\u00F2 essere omesso solo per le colonne con clausole di generazione.

# Arguments:
#
#    {0} = columnName
#
42XAA=Il valore NEW della colonna generata ''{0}'' \u00E8 menzionato nell''azione BEFORE di un trigger. Ci\u00F2 non \u00E8 consentito.

42XAB=NOT NULL \u00E8 consentito solo se si dichiara esplicitamente un tipo di dati.

42XAC=Il valore ''INCREMENT BY'' deve essere diverso da zero.

# Arguments:
#
#    {0} = argName
#    {1} = datatypeName
#    {2} = minValue
#    {3} = maxValue
#
42XAE=Il valore ''{0}'' non \u00E8 compreso nell''intervallo per il tipo di dati ''{1}''. Deve essere compreso tra ''{2}'' e ''{3}''.

# Arguments:
#
#    {0} = minValue
#    {1} = maxValue
#
42XAF=Valore ''MINVALUE non valido ''{0}''. Deve essere minore di ''MAXVALUE: {1}''.

# Arguments:
#
#    {0} = startValue
#    {1} = minValue
#    {2} = maxValue
#
42XAG=Valore ''START WITH'' non valido ''{0}''. Deve essere compreso tra ''{1}'' e ''{2}''.

42XAH=In numerosi contesti potrebbe non essere visualizzata l''espressione NEXT VALUE FOR, ad esempio con le clausole WHERE, ON, HAVING, ORDER BY, DISTINCT, CASE, GENERATION e AGGREGATE, nonch\u00E9 con le funzioni WINDOW e CHECK CONSTRAINTS.

# Arguments:
#
#    {0} = sequenceName
#
42XAI=L''istruzione fa riferimento pi\u00F9 volte alla seguente sequenza: ''{0}''.

# Arguments:
#
#    {0} = clauseName
#
42XAJ=Nell''istruzione CREATE SEQUENCE \u00E8 presente una clausola ''{0}'' ridondante.

42XAK=La tabella di destinazione di un''istruzione MERGE deve essere una tabella di base.

42XAL=La tabella di origine di un''istruzione MERGE deve essere una tabella di base o una funzione tabella.

42XAM=Le tabelle di origine e di destinazione di un''istruzione MERGE non possono avere lo stesso nome correlazione.

42XAN=Caratteristiche vincolo non consentite per NOT NULL.

42XAO=Subquery non consentite nelle clausole WHEN [ NOT ] MATCHED delle istruzioni MERGE.

42XAP=Sinonimi non consentiti quali tabelle di origine o di destinazione delle istruzioni MERGE.

42XAQ=Le tabelle di origine e di destinazione delle istruzioni MERGE non possono avere liste di colonne derivate.

42XAR=Impossibile utilizzare l''operatore NEXT VALUE in un generatore di sequenze di propriet\u00E0 del sistema.

42XBA=Lo schema, la tabella o la colonna non esiste oppure la colonna non \u00E8 un tipo stringa.

42XBB=La tabella non dispone di una chiave primaria.

# Arguments:
#
#    {0} = typeName
#
42XBC=Tipo non supportato dallo strumento opzionale Lucene: ''{0}''

# Arguments:
#
#    {0} = invalidCharacter
#
42XBD=Carattere non consentito negli identificativi Derby utilizzati dallo strumento opzionale Lucene: ''{0}''

42XBE=L''indice Lucene non esiste.

42XBF=Lo schema non esiste oppure l''utente corrente non \u00E8 il DBO e non \u00E8 il proprietario dello schema.

42XBG=Lo strumento luceneSupport \u00E8 stato gi\u00E0 caricato.

42XBH=Lo strumento luceneSupport \u00E8 stato gi\u00E0 scaricato.

# Arguments:
#
#    {0} = directoryName
#
42XBI=Impossibile eliminare ''{0}'' poich\u00E9 non \u00E8 una directory.

# Arguments:
#
#    {0} = columnName
#
42XBJ=Impossibile creare un indice Lucene che comprenda la colonna denominata ''{0}''. Provare a rinominare la colonna mediante la dichiarazione di una vista.

# Arguments:
#
#    {0} = luceneVersion
#    {1} = indexVersion
#
42XBK=La versione Lucene corrente ''{0}'' non \u00E8 in grado di leggere un indice creato dalla versione Lucene ''{1}''.

42XBL=Impossibile creare gli indici Lucene in un database cifrato e, al contrario, impossibile cifrare un database che contiene un indice Lucene.

# Arguments:
#
#    {0} = argumentName
#
42XBM=L''argomento ''{0}'' non pu\u00F2 essere nullo.

# Arguments:
#
#    {0} = fieldName
#
42XBN=Un campo e una chiave hanno lo stesso nome: ''{0}''

# Arguments:
#
#    {0} = fieldName
#
42XBO=Nome campo duplicato o nullo: ''{0}''

# Arguments:
#
#    {0} = className
#
42Y00=La classe ''{0}'' non implementa org.apache.derby.db.AggregateDefinition, quindi non pu\u00F2 essere utilizzata come un''espressione di aggregazione.

# Arguments:
#
#    {0} = constraintName
#
42Y01=Il vincolo ''{0}'' non \u00E8 valido.

# Arguments:
#
#    {0} = statement
#
42Y03.S.0=''{0}'' non \u00E8 riconosciuto come funzione o procedura.

# Arguments:
#
#    {0} = statement
#
42Y03.S.1=''{0}'' non \u00E8 riconosciuto come procedura.

# Arguments:
#
#    {0} = statement
#
42Y03.S.2=''{0}'' non \u00E8 riconosciuto come funzione.

# Arguments:
#
#    {0} = statement
#
42Y03.S.3=''{0}'' \u00E8 una procedura, ma viene utilizzata come una funzione.

# Arguments:
#
#    {0} = statement
#
42Y03.S.4=''{0}'' \u00E8 una funzione, ma viene utilizzata come una procedura.

# Arguments:
#
#    {0} = name
#
42Y04=Impossibile creare una procedura o funzione con EXTERNAL NAME ''{0}'' perch\u00E9 non \u00E8 una lista separata da punti. Il formato previsto \u00E8 <percorso java completo>.<nome metodo>.

# Arguments:
#
#    {0} = key
#
42Y05=Non esiste alcuna chiave esterna denominata ''{0}''.

# Arguments:
#
#    {0} = schemaNamet
#
42Y07=Lo schema ''{0}'' \u00E8 inesistente

42Y08=I vincoli della chiave esterna non sono consentiti sulle tabelle di sistema.

42Y09=I metodi Void sono consentiti solo all''interno di un''istruzione CALL.

42Y10=Un costruttore di tabelle non presente in un''istruzione INSERT ha tutti i parametri ? in una delle relative colonne. Per ciascuna colonna, almeno una riga deve avere un argomento diverso da parametro.

# Arguments:
#
#    {0} = clauseName
#
42Y11=Con la clausola ''{0}'' \u00E8 necessaria una specifica di join.

# Arguments:
#
#    {0} = expressionType
#
42Y12=La clausola ON di una specifica JOIN \u00E8 un''espressione ''{0}''. Deve essere un''espressione BOOLEAN.

# Arguments:
#
#    {0} = columnName
#
42Y13=Il nome colonna ''{0}'' compare pi\u00F9 di una volta nell''istruzione CREATE VIEW.

# Arguments:
#
#    {0} = methodName
#    {1} = className
#
42Y16=Non \u00E8 stato trovato alcun metodo ''{0}'' pubblico o statico nella classe ''{1}''. \u00C8 possibile che il metodo esista ma non sia pubblico oppure non sia statico. 

# Arguments:
#
#    {0} = aggregateType
#    {1} = type
#
42Y22=L''aggregazione {0} non pu\u00F2 funzionare sul tipo {1}.

# Arguments:
#
#    {0} = colunmName
#
42Y23=Informazioni sul tipo JDBC restituite per la colonna {0} non corrette.

# Arguments:
#
#    {0} = viewName
#
42Y24=La vista ''{0}'' non \u00E8 aggiornabile. (Le viste non sono al momento aggiornabili.) 

# Arguments:
#
#    {0} = tableName
#
42Y25=''{0}'' \u00E8 una tabella di sistema. Gli utenti non possono modificare i contenuti di tale tabella.

42Y26.S.0=Gli aggregati non sono consentiti nella lista GROUP BY.

42Y26.S.1=Le subquery non sono consentite nella lista GROUP BY.

42Y27=I parametri non sono consentiti nell''azione del trigger.

42Y29=La lista SELECT di una query non raggruppata contiene almeno un''espressione non valida. Quando una lista SELECT contiene almeno un''aggregazione, tutte le voci devono essere espressioni di aggregazione valide.

42Y30=La lista SELECT di una query raggruppata contiene almeno un''espressione non valida. Se una lista SELECT contiene GROUP BY, la lista pu\u00F2 contenere solo espressioni di raggruppamento valide ed espressioni di aggregazione valide.  

# Arguments:
#
#    {0} = className
#    {1} = aggregateName
#    {2} = type
#
42Y32=La classe di aggregazione ''{0}'' per l''aggregato ''{1}'' sul tipo {2} non implementa org.apache.derby.iapi.sql.execute.ExecAggregator. 

# Arguments:
#
#    {0} = aggregateName
#
42Y33=L''aggregazione {0} contiene una o pi\u00F9 aggregazioni.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
42Y34=Il nome colonna ''{0}'' corrisponde a pi\u00F9 di una colonna di risultati nella tabella ''{1}''.

# Arguments:
#
#    {0} = reference
#
42Y35=Il riferimento colonna ''{0}'' non \u00E8 valido. Quando una lista SELECT contiene almeno un''aggregazione, tutte le voci devono essere espressioni di aggregazione valide.  

# Arguments:
#
#    {0} = reference
#
42Y36=Il riferimento colonna ''{0}'' non \u00E8 valido o fa parte di un''espressione non valida. Per una lista SELECT con GROUP BY, le colonne e le espressioni selezionate possono contenere solo espressioni di raggruppamento e di aggregazione valide.

# Arguments:
#
#    {0} = javaTypeName
#
42Y37=''{0}'' \u00E8 un tipo primitivo Java e non pu\u00F2 essere utilizzato con questo operatore.

# Arguments:
#
#    {0} = tableName
#
42Y38=insertMode = la sostituzione non \u00E8 consentita su un inserimento dove la tabella di destinazione, ''{0}'', viene presa come riferimento in SELECT.

# Arguments:
#
#    {0} = sqlObjectName
#
42Y39=''{0}'' non compare in una definizione CHECK CONSTRAINT perch\u00E9 potrebbe restituire risultati non deterministici.

# Arguments:
#
#    {0} = columnName
#    {1} = triggerName
#
42Y40=''{0}'' compare pi\u00F9 volte nella lista colonne UPDATE OF per il trigger ''{1}''.

# Arguments:
#
#    {0} = storedPreparedStatementName
#
42Y41=Impossibile richiamare direttamente ''{0}'' tramite EXECUTE STATEMENT poich\u00E9 fa parte di un trigger.

# Arguments:
#
#    {0} = dataType
#    {1} = scaleValue
#
42Y42=La scala ''{1}'' non \u00E8 un valore di scala valido per ''{0}''.

# Arguments:
#
#    {0} = scaleValue
#    {1} = precision
#
42Y43=La scala ''{0}'' non \u00E8 un valore di scala valido con precisione di ''{1}''.

# Arguments:
#
#    {0} = key
#    {1} = key
#
42Y44=Chiave non valida ''{0}'' specificata nella lista Propriet\u00E0 di una lista FROM. Le chiavi sensibili al maiuscolo/minuscolo attualmente supportate sono ''{1}''. 

# Arguments:
#
#    {0} = vtiName
#
42Y45=Impossibile collegare VTI ''{0}'' poich\u00E9 \u00E8 un VTI trigger speciale e questa istruzione non fa parte di un''azione del trigger o della clausola WHEN.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#
42Y46=Lista Propriet\u00E0 non valida nella lista FROM. Non esiste alcun indice ''{0}'' sulla tabella ''{1}''.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42Y48=Lista Propriet\u00E0 non valida nella lista FROM. Non esiste alcun vincolo denominato ''{0}'' sulla tabella ''{1}'' oppure il vincolo non possiede un indice di copia.

# Arguments:
#
#    {0} = key
#
42Y49=Pi\u00F9 valori specificati per la chiave propriet\u00E0 ''{0}''. 

# Arguments:
#
#    {0} = tableName
#
42Y50=La lista Propriet\u00E0 per la tabella ''{0}'' pu\u00F2 contenere i valori per l''indice o per il vincolo ma non per entrambi.

# Arguments:
#
#    {0} = sqlText
#    {1} = sqlObjectName
#
42Y55=Impossibile eseguire ''{0}'' su ''{1}'' perch\u00E9 inesistente.

# Arguments:
#
#    {0} = strategyValue
#    {1} = tableName
#
42Y56=Strategia di join ''{0}'' non valida specificata nella lista Propriet\u00E0 della tabella ''{1}''. I valori attualmente supportati per una strategia di join sono: ''hash'' e ''nestedloop''.

# Arguments:
#
#    {0} = invalidNumber
#    {1} = optimizerOverrideName
#
42Y58=NumberFormatException durante la conversione del valore ''{0}'' per la sostituzione dell''ottimizzatore ''{1}''.

# Arguments:
#
#    {0} = invalidNumber
#
42Y59=Valore non valido, ''{0}'', specificato per la sostituzione hashInitialCapacity. Il valore deve essere maggiore di 0.

# Arguments:
#
#    {0} = invalidNumber
#
42Y60=Valore non valido, ''{0}'', specificato per la sostituzione hashLoadFactor. Il valore deve essere maggiore di 0.0 e minore o uguale a 1.0.

# Arguments:
#
#    {0} = invalidNumber
#
42Y61=Valore non valido, ''{0}'', specificato per la sostituzione hashMaxCapacity. Il valore deve essere maggiore di 0.

# Arguments:
#
#    {0} = statement
#    {1} = viewName
#
42Y62=''{0}'' non consentito su ''{1}'' perch\u00E9 \u00E8 una vista.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#
42Y63=L''hash join richiede il predicato equijoin ottimizzabile su una colonna nell''indice o nella guida selezionata. Un predicato equijoin ottimizzabile non esiste su qualsiasi colonna presente nella tabella o nell''indice ''{0}''. Utilizzare la sostituzione dell''ottimizzatore ''indice'', per specificare un indice o un heap sulla tabella ''{1}''.

# Arguments:
#
#    {0} = invalidNumber
#
42Y64=Valore bulkFetch di ''{0}'' non valido. Il valore minimo per bulkFetch \u00E8 1.

# Arguments:
#
#    {0} = joinType
#
42Y65=bulkFetch non \u00E8 consentito sui join ''{0}''.

42Y66=bulkFetch non consentito sui cursori aggiornabili. 

# Arguments:
#
#    {0} = schemaNamet
#
42Y67=Impossibile eliminare lo schema ''{0}''.

42Y69=Nessun piano di esecuzione valido trovato per questa istruzione. Le cause possono essere molteplici: 1) si \u00E8 specificata una strategia di hash join, ma l''hash join non \u00E8 consentito (nessun equijoin ottimizzabile); 2) si sta tentando di unire tramite join due tabelle virtuali esterne, ognuna delle quali fa riferimento all''altra, pertanto non \u00E8 possibile valutare l''istruzione; 3) si \u00E8 specificata una forma di piano che l''ottimizzatore non prenderebbe mai in considerazione.

42Y70=L''utente ha specificato un ordine non valido per i collegamenti. Ci\u00F2 potrebbe essere dovuto al fatto che una colonna di join \u00E8 stata inviata, da una tabella interna ad una virtuale esterna, come parametro.

# Arguments:
#
#    {0} = procedureName
#
42Y71=Impossibile eliminare la funzione o procedura di sistema ''{0}''.

# Arguments:
#
#    {0} = statement
#
42Y82=Impossibile eliminare l''istruzione preparata e memorizzata ''{0}'', generata dal sistema, tramite DROP STATEMENT. Fa parte di un trigger. 

# Arguments:
#
#    {0} = aggregateName
#
42Y83=Un valore NULL senza tipo non \u00E8 consentito come argomento per l''aggregazione di {0}. Associare il valore NULL a un tipo adeguato.

# Arguments:
#
#    {0} = sqlText
#
42Y84=''{0}'' potrebbe non comparire in una definizione DEFAULT.

42Y85=La parola chiave DEFAULT non \u00E8 consentita in una clausola VALUES che compare all''interno di un''istruzione INSERT.

42Y90=FOR UPDATE non consentito in questo tipo di istruzione.  

42Y91=La clausola USING non \u00E8 consentita in una EXECUTE STATEMENT per un''azione del trigger.

# Arguments:
#
#    {0} = sqlKeyword
#    {1} = sqlKeyword
#
42Y92=I trigger {0} possono fare riferimento solo alle variabili/tabelle della transazione {1}.

42Y93=Clausola REFERENCING non valida: \u00E8 consentito solo un nome per ogni tipo di variabile/tabella della transazione.

42Y94=AND o OR possiedono un operando diverso dal valore booleano. Il risultato degli operandi di AND e OR deve essere TRUE, FALSE o UNKNOWN.  

# Arguments:
#
#    {0} = operatorName
#    {1} = operandType
#    {2} = operandType
#
42Y95=L''operatore ''{0}'' con un tipo di operando di sinistra di ''{1}'' e di destra di ''{2}'' non \u00E8 supportato.

# Arguments:
#
#    {0} = lineNumber
#    {1} = columnName
#
42Y97=Carattere escape non valido alla riga ''{0}'', colonna ''{1}''.

# Arguments:
#
#    {0} = sqlObjectName
#
42Y98=Impossibile utilizzare ''{0}'' in questo contesto perch\u00E9 potrebbe restituire risultati inaffidabili.

42Z02=Non sono supportate pi\u00F9 aggregazioni DISTINCT alla volta.

42Z07=Le aggregazioni non sono consentite nella clausola ON.

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
42Z08=Sostituzione inserimento di massa non consentito su ''{0}'' perch\u00E9 possiede un trigger ({1}) abilitato.

42Z09=Le aggregazioni non sono consentite nella clausola di corrispondenza MERGE.

# Arguments:
#
#    {0} = columnName
#
42Z15=Tipo non valido specificato per la colonna ''{0}''. Non \u00E8 possibile modificare il tipo di una colonna.  

42Z16=\u00C8 possibile modificare la lunghezza solo per le colonne di tipo VARCHAR, CLOB e BLOB. 

# Arguments:
#
#    {0} = columnName
#
42Z17=Lunghezza non valida specificata per la colonna ''{0}''. La lunghezza deve essere maggiore della lunghezza della colonna corrente.

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z18=La colonna ''{0}'' fa parte del vincolo della chiave esterna ''{1}''. Per modificare la lunghezza di questa colonna, \u00E8 necessario innanzitutto eliminare il vincolo, eseguire ALTER TABLE, quindi ricreare il vincolo.

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z19=La colonna ''{0}'' viene utilizzata come riferimento da almeno un vincolo della chiave esterna ''{1}''. Per modificare la lunghezza di questa colonna, \u00E8 necessario eliminare i vincoli di riferimento, eseguire ALTER TABLE, quindi ricreare i vincoli. 

# Arguments:
#
#    {0} = columnName
#
42Z20=Impossibile rendere annullabile la colonna ''{0}''. Fa parte di una chiave primaria o di un vincolo univoco che non pu\u00F2 contenere colonne annullabili.

# Arguments:
#
#    {0} = columnName
#
42Z20.S.1=Impossibile rendere annullabile la colonna ''{0}''. Fa parte di una chiave primaria che non pu\u00F2 contenere colonne annullabili.

# Arguments:
#
#    {0} = columnName
#
42Z21=Incremento non valido specificato per l''identit\u00E0 della colonna ''{0}''. L''incremento deve essere diverso da zero.  

# Arguments:
#
#    {0} = columnName
#
42Z22=Tipo non valido specificato per l''identit\u00E0 della colonna ''{0}''. Gli unici tipi validi per l''identit\u00E0 delle colonne sono BIGINT, INT, SMALLINT.

# Arguments:
#
#    {0} = columnName
#
42Z23=Tentativo di modificare l''identit\u00E0 della colonna ''{0}''. 

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42Z24=Overflow nel valore identit\u00E0 della colonna ''{1}'' nella tabella ''{0}''.

42Z25=Errore interno nel contatore di identit\u00E0. L''aggiornamento \u00E8 stato richiamato senza argomenti con il valore corrente = NULL.

# Arguments:
#
#    {0} = columnName
#
42Z26=Impossibile rendere annullabile una colonna, ''{0}'', con un valore predefinito di identit\u00E0.

# Arguments:
#
#    {0} = columnName
#
42Z27=Impossibile modificare una colonna annullabile, ''{0}'', in modo che assuma un valore predefinito di identit\u00E0.

# Arguments:
#
#    {0} = queryTreeNodeIdentifier
#
42Z50=Errore interno: impossibile generare il codice per {0}.

# Arguments:
#
#    {0} = number
#
42Z53=Errore interno: tipo di attivit\u00E0 da generare per la scelta del nodo {0} non conosciuta.

# Arguments:
#
#    {0} = sqlText
#    {1} = propertyName
#    {2} = propertyValue
#
42Z60={0} non consentito a meno che la propriet\u00E0 del database {1} contenga il valore ''{2}''.

42Z70=Il collegamento diretto a un valore XML non \u00E8 consentito; provare a utilizzare XMLPARSE.

42Z71=I valori XML non sono consentiti nei set di risultati di livello superiore; provare a utilizzare XMLSERIALIZE.

# Arguments:
#
#    {0} = keywords
#    {1} = lineNumber
#    {2} = columnNumber
#
42Z72=Parole chiave SQL/XML ''{0}'' mancanti alla riga {1}, colonna {2}.

# Arguments:
#
#    {0} = typeName
#
42Z73=Tipo di destinazione non valido per XMLSERIALIZE: ''{0}''.

# Arguments:
#
#    {0} = featureName
#
42Z74=Funzione XML non supportata: ''{0}''.

42Z75=L''espressione della query XML deve essere un valore stringa.

42Z76=Non sono consentiti pi\u00F9 elementi di contesto XML.

# Arguments:
#
#    {0} = dataType
#
42Z77=L''elemento di contesto deve contenere il tipo ''XML''; ''{0}'' non \u00E8 consentito.

42Z79=Impossibile determinare il tipo di parametro per XMLPARSE; tentare di utilizzare un CAST.

# Arguments:
#
#    {0} = className
#
42Z90=La classe ''{0}'' non restituisce un ResultSet aggiornabile.

# This is a kind of query fragment, which may or may not appear in certain query contexts.
#
42Z91=SELECT

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
#
42Z92=lettura ripetibile

# Arguments:
#
#    {0} = constraintName
#    {1} = constraintName
#
42Z93=I vincoli ''{0}'' e ''{1}'' possiedono lo stesso insieme di colonne e ci\u00F2 non \u00E8 consentito. 

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z97=La ridenominazione della colonna ''{0}'' causer\u00E0 l''interruzione del vincolo di controllo ''{1}''.

42Z99=I valori di stringa o esadecimale non possono superare i 64 K.

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
#
42Z9A=lettura senza commit

42Z9D.S.1=Le procedure che modificano i dati SQL non sono consentite nei trigger BEFORE.

# Arguments:
#
#    {0} = statement
#    {1} = triggerName
#
42Z9D=Le istruzioni ''{0}'' non sono consentite nei trigger ''{1}''.

# Arguments:
#
#    {0} = constraintName
#    {1} = constraintType
#
42Z9E=Il vincolo ''{0}'' non \u00E8 un vincolo {1}.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#    {2} = number
#
42Z9F=Troppi indici ({0}) nella tabella {1}. Il limite \u00E8 {2}.  

42ZA0=Istruzione troppo complessa. Tentare di scrivere nuovamente la query per eliminare la complessit\u00E0. L''eliminazione di molte espressioni duplicate o l''interruzione della query e la memorizzazione di risultati provvisori in una tabella temporanea possono essere di aiuto per la correzione di questo errore.

# Arguments:
#
#    {0} = batch
#
42ZA1=SQL non valido in batch: ''{0}''.

# Arguments:
#
#    {0} = dataType
#    {1} = collationType
#    {2} = dataType
#    {3} = collationType
#
42ZA2=L''operando del predicato LIKE con tipo {0} e ordinamento {1} non \u00E8 compatibile con l''operando del pattern LIKE con tipo {2} e ordinamento {3}.

# Arguments:
#
#    {0} = collationType
#    {1} = schemaName
#
42ZA3=La tabella avrebbe il tipo di ordinamento {0}, diverso dall''ordinamento dello schema {1}. Questa operazione non \u00E8 supportata.

42ZB1=Lo stile parametro DERBY_JDBC_RESULT_SET \u00E8 consentito solo per le funzioni tabella.

42ZB2=Le funzioni tabella possono disporre solo dello stile parametro DERBY_JDBC_RESULT_SET.

42ZB3=XML non \u00E8 consentito come tipo di dati di un''aggregazione definita dall''utente o di una colonna restituita da una funzione tabella.

# Arguments:
#
#    {0} = schemaName
#    {1} = functionName
#
42ZB4=''{0}''.''{1}'' non identifica una funzione tabella.

# Arguments:
#
#    {0} = className
#
42ZB5=La classe ''{0}'' implementa VTICosting ma non fornisce un costruttore pubblico senza argomento.

42ZB6=\u00C8 previsto che una funzione tabella restituisca un valore scalare non un set di righe.

# Arguments:
#
#    {0} = columnName
#
42ZB7=Riferimento non valido alla colonna ''{0}'' da parte di una funzione tabella o VTI.

# Arguments:
#
#    {0} = windowName
#
42ZC0=Finestra ''{0}'' non definita.

42ZC1=\u00C8 supportata una sola finestra.

# Arguments:
#
#    {0} = clauseName
#
42ZC2=Funzione finestra non valida in questo contesto: clausola ''{0}''

# Arguments:
#
#    {0} = aggregateName
#
42ZC3=Un''aggregazione definita dall''utente potrebbe non avere il nome di un''aggregazione definita dallo standard SQL o il nome di una funzione Derby integrata che ha un argomento: ''{0}''

# Arguments:
#
#    {0} = schemaName
#    {1} = aggregateName
#    {2} = className
#
42ZC4=L''aggregazione definita dall''utente ''{0}''.''{1}'' \u00E8 associata alla classe esterna ''{2}''. Non \u00E8 stato possibile risolvere i tipi di parametri di tale classe.

# Arguments:
#
#    {0} = schemaName
#    {1} = aggregateName
#    {2} = javaDataType
#    {3} = javaDataType
#
42ZC6=In base alla dichiarazione l''aggregazione definita dall''utente ''{0}''.''{1}'' dispone del tipo Java di input seguente: ''{2}''. Questo non estende il tipo Java di input di associazione effettivo seguente: ''{3}''.

# Arguments:
#
#    {0} = schemaName
#    {1} = aggregateName
#    {2} = javaDataType
#    {3} = javaDataType
#
42ZC7=In base alla dichiarazione l''aggregazione definita dall''utente ''{0}''.''{1}'' dispone del tipo Java restituito seguente: ''{2}''. Questo non estende il tipo Java restituito di associazione effettivo seguente: ''{3}''.

# Arguments:
#
#    {0} = className
#    {1} = schemaName
#    {2} = aggregateName
#    {3} = detailedMessage
#
42ZC8=Non \u00E8 stato possibile creare un''istanza della classe di implementazione ''{0}'' per l''aggregazione definita dall''utente ''{1}''.''{2}'' oppure il formato della classe di implementazione \u00E8 errato. Segue il messaggio dettagliato: {3}

42ZC9=Una routine varargs deve avere lo stile parametro DERBY o DERBY_JDBC_RESULT_SET.

42ZCA=Lo stile parametro DERBY \u00E8 consentito solo per le routine varargs.

42ZCB=Una procedura varargs non pu\u00F2 restituire set di risultati.

# Arguments:
#
#    {0} = rowSourceCountInPlan
#    {1} = actualRowSourceCount
#
42ZCC=Override ottimizzatore non valido. Il piano contiene {0} row source, mentre dovrebbe contenerne {1}.

42ZCD=Override ottimizzatore non valido. Questo piano non \u00E8 una struttura con profondit\u00E0 a sinistra.

42ZCE=Override ottimizzatore non valido. Row source non risolte.

# Arguments:
#
#    {0} = codePage
#    {1} = codePage
#
57017.C=Non esiste una conversione disponibile per la pagina del codice di origine, {0}, alla pagina del codice di destinazione, {1}. La connessione \u00E8 stata terminata.

58009.C.10=Eccezione del protocollo di rete: solo una lunghezza VCM, VCS pu\u00F2 essere maggiore di 0. La connessione \u00E8 stata terminata.

58009.C.11=La connessione \u00E8 stata terminata perch\u00E9 la codifica non \u00E8 supportata.

# Arguments:
#
#    {0} = codePoint
#    {1} = codePoint
#
58009.C.12=Eccezione del protocollo di rete: il punto di codice reale, {0}, non corrisponde al punto di codice previsto, {1}. La connessione \u00E8 stata terminata.

58009.C.13=Eccezione del protocollo di rete: la raccolta DDM contiene meno di 4 byte di dati. La connessione \u00E8 stata terminata.

58009.C.14=Eccezione del protocollo di rete: stack di raccolta non vuoto al termine della stessa analisi della catena ID. La connessione \u00E8 stata terminata.

58009.C.15=Eccezione del protocollo di rete: lunghezza DSS non 0 al termine della stessa analisi di catena ID. La connessione \u00E8 stata terminata.

58009.C.16=Eccezione del protocollo di rete: DSS concatenato con lo stesso ID al termine della stessa analisi di catena ID. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = number
#
58009.C.17=Eccezione del protocollo di rete: interruzione del flusso durante la lettura di InputStream, parametro #{0}. La connessione \u00E8 stata terminata.

58009.C.18=Eccezione del protocollo di rete: FDOCA LID non valido. La connessione \u00E8 stata terminata.

58009.C.19=Eccezione del protocollo di rete: SECTKN non restituito. La connessione \u00E8 stata terminata.

58009.C.20=Eccezione del protocollo di rete: solo una lunghezza VCM, NVCS pu\u00F2 essere non nulla. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = length
#
58009.C.21=Eccezione del protocollo di rete: lunghezza SCLDTA, {0}, non valida per RDBNAM. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = length
#
58009.C.7=Eccezione del protocollo di rete: lunghezza SCLDTA, {0}, non valida per RDBCOLID. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = length
#
58009.C.8=Eccezione del protocollo di rete: lunghezza SCLDTA, {0}, non valida per PKGID. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = length
#    {1} = sqlApplicationManager
#
58009.C.9=Eccezione del protocollo di rete: lunghezza PKGNAMCSN, {0}, non valida in SQLAM {1}. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = managerCodePoint
#    {1} = level
#
58010.C=Si \u00E8 verificato un errore del protocollo di rete. Non \u00E8 stato possibile stabilire una connessione perch\u00E9 il gestore {0} a livello {1} non \u00E8 supportato dal server. 

# Arguments:
#
#    {0} = distributedDataManagementCommand
#
58014.C=Il comando DDM 0x{0} non \u00E8 supportato. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = distributedDataManagementObject
#
58015.C=L''oggetto DDM 0x{0} non \u00E8 supportato. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = distributedDataManagementParameter
#
58016.C=Il parametro DDM 0x{0} non \u00E8 supportato. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = distributedDataManagementParameterValue
#
58017.C=Il valore del parametro DDM 0x{0} non \u00E8 supportato. \u00C8 possibile che una variabile host di input non sia presente nell''intervallo che il server supporta. La connessione \u00E8 stata terminata.

# Arguments:
#
#    {0} = columnName
#
X0A00.S=Nella lista di selezione la colonna ''{0}'' \u00E8 menzionata due volte. Questo non \u00E8 consentito in query con clausole GROUP BY o HAVING. Tentare di effettuare l''aliasing di una delle colonne in conflitto al fine di acquisire un nome univoco.

# Arguments:
#
#    {0} = tableName
#    {1} = mode
#
X0X02.S=La tabella ''{0}'' non pu\u00F2 essere bloccata nella modalit\u00E0 ''{1}''.

X0X03.S=Stato transazione non valido - il cursore attivo richiede lo stesso livello di isolamento

# Arguments:
#
#    {0} = tableName
#
X0X05.S=Tabella/Vista ''{0}'' inesistente.

# Arguments:
#
#    {0} = fileName
#    {1} = classpath
#
X0X07.S=Impossibile rimuovere il file jar ''{0}'' perch\u00E9 si trova su derby.database.classpath ''{0}''.

# Arguments:
#
#    {0} = columnArrayLength
#
X0X0D.S=Lunghezza array colonna non valida ''{0}''. Per restituire chiavi generate, l''array colonna deve avere una lunghezza pari a 1 e deve contenere solo la colonna IDENTITY.

# Arguments:
#
#    {0} = columnPosition
#    {1} = tableName
#
X0X0E.S=La tabella ''{1}'' non contiene una colonna generata automaticamente nella posizione ''{0}''.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
X0X0F.S=La tabella ''{1}'' non contiene una colonna generata automaticamente denominata ''{0}''.

X0X10.S=La clausola USING ha restituito pi\u00F9 di una riga; sono consentiti solo ResultSet di righe singole.

X0X11.S=La clausola USING non ha restituito alcun risultato, impossibile impostare alcun parametro. 

# Arguments:
#
#    {0} = fileName
#    {1} = schemaNamet
#
X0X13.S=Il file Jar ''{0}'' non esiste nello schema ''{1}''.

# Arguments:
#
#    {0} = type
#
X0X57.S=\u00C8 stato effettuato un tentativo di inserire un valore Java di tipo ''{0}'' in un valore SQL ma non esiste un tipo SQL corrispondente. Il valore Java probabilmente \u00E8 il risultato della chiamata a un metodo o dell''accesso a un campo.

# Arguments:
#
#    {0} = cursorName
#
X0X60.S=Cursore con nome ''{0}'' gi\u00E0 esistente.

# Arguments:
#
#    {0} = indexName
#    {1} = schemaName
#    {2} = tableName
#    {3} = rowLocation
#    {4} = columnName
#    {5} = dataValue
#    {6} = dataValue
#    {7} = indexKey
#
X0X61.S=I valori della colonna ''{4}'' nell''indice ''{0}'' e della tabella ''{1}.{2}'' non corrispondono per la posizione della riga {3}. Il valore presente nell''indice \u00E8 ''{5}'', mentre il valore presente nella tabella di base \u00E8 ''{6}''. La chiave completa dell''indice, che comprende la posizione della riga, \u00E8 ''{7}''. L''azione di correzione suggerita \u00E8 quella di ricreare l''indice.

# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#    {2} = rowLocation
#    {3} = indexKey
#
X0X62.S=Incoerenza rilevata tra la tabella ''{0}'' e l''indice ''{1}''. Errore durante il tentativo di recuperare la posizione della riga ''{2}'' dalla tabella. La chiave completa dell''indice, che comprende la posizione della riga, \u00E8 ''{3}''. L''azione di correzione suggerita \u00E8 quella di ricreare l''indice.

# Arguments:
#
#    {0} = exceptionText
#
X0X63.S=\u00C8 stata riscontrata IOException ''{0}''.

# Arguments:
#
#    {0} = type
#
X0X67.S=Le colonne di tipo ''{0}'' non possono essere utilizzate in CREATE INDEX, ORDER BY, GROUP BY, UNION, INTERSECT, EXCEPT o DISTINCT perch\u00E9 i confronti per tale tipo non sono supportati.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#
X0X81.S={0} ''{1}'' inesistente.

# Arguments:
#
#    {0} = indexName
#    {1} = indexType
#
X0X85.S=L''indice ''{0}'' non \u00E8 stato creato poich\u00E9 ''{1}'' non \u00E8 un tipo di indice valido.

X0X86.S=0 \u00E8 un valore di parametro non valido per ResultSet.absolute(int row).

X0X87.S=Impossibile chiamare ResultSet.relative(int row) quando il cursore non \u00E8 posizionato su una riga.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#
X0X95.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' perch\u00E9 esiste un ResultSet aperto dipendente da tale oggetto.

# Arguments:
#
#    {0} = indexName
#
X0X99.S=L''indice ''{0}'' non esiste.

# Arguments:
#
#    {0} = sqlObjectName
#
X0Y16.S=''{0}'' non \u00E8 una vista. Se si tratta di una tabella, utilizzare DROP TABLE.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = viewName
#
X0Y23.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00E9 VIEW ''{2}'' \u00E8 dipendente da tale oggetto.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = statement
#
X0Y24.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00E9 STATEMENT ''{2}'' \u00E8 dipendente da tale oggetto.

# Arguments:
#
#    {0} = operationName
#    {1} = sqlObjectName
#    {2} = sqlObjectType
#    {3} = sqlObjectName
#
X0Y25.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00E9 {2} ''{3}'' \u00E8 dipendente da tale oggetto.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y26.S=L''indice ''{0}'' deve essere contenuto nello stesso schema della tabella ''{1}''.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y28.S=Impossibile creare l''indice ''{0}'' sulla tabella di sistema ''{1}''. Gli utenti non possono creare gli indici sulle tabelle di sistema.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = tableName
#
X0Y29.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00E9 TABLE ''{2}'' \u00E8 dipendente da tale oggetto.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = routineName
#
X0Y30.S=Impossibile eseguire l''operazione ''{0}'' sull''oggetto ''{1}'' poich\u00E9 ROUTINE ''{2}'' \u00E8 dipendente da tale oggetto.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#    {2} = sqlObjectType
#    {3} = sqlObjectName
#
X0Y32.S={0} ''{1}'' esiste gi\u00E0 in {2} ''{3}''.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y38.S=Impossibile creare l''indice ''{0}'' perch\u00E9 la tabella ''{1}'' non esiste.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = tableName
#
X0Y41.S=Il vincolo ''{0}'' non \u00E8 valido perch\u00E9 la tabella di riferimento {1} non presenta una chiave primaria. Aggiungere una chiave primaria a {1} oppure specificare esplicitamente le colonne di un vincolo univoco cui fa riferimento questa chiave esterna. 

# Arguments:
#
#    {0} = constraintName
#
X0Y42.S=Vincolo ''{0}'' non valido: i tipi di colonne della chiave esterna non corrispondono ai tipi delle colonne di riferimento.

# Arguments:
#
#    {0} = constraintName
#    {1} = number
#    {2} = number
#
X0Y43.S=Vincolo ''{0}'' non valido: il numero di colonne ({1}) non corrisponde al numero di colonne presenti nella chiave di riferimento ({2}).

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y44.S=Vincolo ''{0}'' non valido: nessun vincolo di chiave univoca o primaria sulla tabella ''{1}'' corrisponde al numero e ai tipi di colonne presenti nella chiave esterna.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y45.S=Impossibile aggiungere o abilitare il vincolo della chiave esterna ''{0}'' sulla tabella ''{1}'' poich\u00E9 una o pi\u00F9 chiavi esterne non dispongono di chiavi di riferimento corrispondenti.  

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y46.S=Vincolo ''{0}'' non valido: la tabella di riferimento ''{1}'' non esiste.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y47.S=Vincolo ''{0}'' non valido: il vincolo UNIQUE KEY o PRIMARY KEY nella tabella ''{1}'' \u00E8 differibile e l''azione di riferimento \u00E8 CASCADE o SET NULL.

# Arguments:
#
#    {0} = schemaNamet
#
X0Y54.S=Impossibile eliminare lo schema ''{0}'' perch\u00E9 non \u00E8 vuoto.

# Arguments:
#
#    {0} = indexName
#    {1} = schemaNamet
#    {2} = tableName
#    {3} = number
#    {4} = number
#
X0Y55.S=Il numero di righe presenti nella tabella di base non corrisponde al numero di righe presenti in almeno 1 degli indici sulla tabella. L''indice ''{0}'' nella tabella ''{1}.{2}'' ha {3} righe mentre la tabella di base ne ha {4}. L''azione di correzione suggerita \u00E8 quella di ricreare l''indice.

# Arguments:
#
#    {0} = sqlText
#    {1} = tableName
#
X0Y56.S=''{0}'' non \u00E8 consentito nella tabella di sistema ''{1}''.

# Arguments:
#
#    {0} = tableName
#
X0Y57.S=Impossibile aggiungere una colonna non annullabile alla tabella ''{0}'' poich\u00E9 tale tabella contiene almeno una riga. Le colonne non annullabili possono essere aggiunte solo alle tabelle vuote.

# Arguments:
#
#    {0} = tableName
#
X0Y58.S=Tentativo di aggiungere un vincolo di chiave primaria alla tabella ''{0}'' non riuscito poich\u00E9 la tabella possiede gi\u00E0 un vincolo di quel tipo. Una tabella pu\u00F2 disporre solo di un singolo vincolo di chiave primaria.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = rowCount
#
X0Y59.S=Tentativo di aggiungere o abilitare una o pi\u00F9 vincoli sulla tabella ''{1}'' non riuscito, poich\u00E9 la tabella contiene {2} righe che violano i seguenti vincoli di controllo: {0}.

# Arguments:
#
#    {0} = tableName
#
X0Y63.S=Il comando sulla tabella ''{0}'' non \u00E8 riuscito perch\u00E9 dati nulli sono stati trovati nelle colonne indice/vincolo univoco o chiave primaria. Tutte le colonne presenti in una chiave indice primaria o univoca non devono essere nulle.  

# Arguments:
#
#    {0} = tableName
#
X0Y63.S.1=Il comando sulla tabella ''{0}'' non \u00E8 riuscito perch\u00E9 sono stati trovati dati nulli nelle colonne indice/chiave primaria. Tutte le colonne presenti in una chiave primaria non devono essere nulle.  

X0Y66.S=Impossibile eseguire il commit in una connessione nidificata quando esiste un''operazione in sospeso nella connessione parent.

X0Y67.S=Impossibile eseguire il rollback in una connessione nidificata quando esiste un''operazione in sospeso nella connessione parent.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#
X0Y68.S={0} ''{1}'' esiste gi\u00E0.

# Arguments:
#
#    {0} = triggerName
#
X0Y69.S=DDL non \u00E8 supportato nel trigger {0}.

# Arguments:
#
#    {0} = triggerName
#    {1} = tableName
#
X0Y70.S=INSERT, UPDATE e DELETE non sono consentiti sulla tabella {1} poich\u00E9 il trigger {0} \u00E8 attivo.

# Arguments:
#
#    {0} = triggerName
#
X0Y71.S=La manipolazione della transazione, ad esempio SET ISOLATION, non \u00E8 consentita poich\u00E9 il trigger {0} \u00E8 attivo.

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
X0Y72.S=Sostituzione inserimento di massa non consentito su ''{0}'' perch\u00E9 possiede un trigger ({1}) abilitato.

X0Y77.S=Impossibile eseguire l''istruzione di isolamento della transazione di impostazione su una transazione globale in corso poich\u00E9 verrebbe implicitamente eseguito il commit di tale transazione.

X0Y78.S=Impossibile chiamare Statement.executeQuery() tramite un''istruzione che restituisce un conteggio righe.

# Arguments:
#
#    {0} = javaInterfaceName
#    {1} = javaInterfaceName
#
X0Y78.S.1={0}.executeQuery() non pu\u00F2 essere richiamato poich\u00E9 sono stati restituiti pi\u00F9 set di risultati. Utilizzare {1}.execute() per acquisire pi\u00F9 risultati.

# Arguments:
#
#    {0} = javaInterfaceName
#    {1} = javaInterfaceName
#
X0Y78.S.2={0}.executeQuery() \u00E8 stato richiamato ma non \u00E8 stato restituito alcun set di risultati. Utilizzare {1}.executeUpdate() per non query.

X0Y79.S=Impossibile chiamare Statement.executeUpdate() tramite un''istruzione che restituisce ResultSet.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
X0Y80.S=ALTER tabella ''{0}'' non riuscita. Dati nulli trovati nella colonna ''{1}''.

# Arguments:
#
#    {0} = rowName
#    {1} = id
#
X0Y83.S=Avvertenza: durante la cancellazione di una riga da una tabella, la riga dell''indice della riga della tabella di base {0} non \u00E8 stata trovata nell''indice con ID conglomerato {1}. Questo problema \u00E8 stato corretto automaticamente come parte dell''operazione di cancellazione.

# Arguments:
#
#    {0} = sequenceName
#
X0Y84.T=Elevata conflittualit\u00E0 nella sequenza {0}. Ci\u00F2 \u00E8 probabilmente dovuto a una scansione senza commit del catalogo SYS.SYSSEQUENCES. Non eseguire query direttamente su questo catalogo, ma utilizzare la funzione SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE per visualizzare il valore corrente di un generatore di sequenze.

# Arguments:
#
#    {0} = propertyName
#    {1} = className
#
X0Y85.S=La propriet\u00E0 Derby ''{0}'' identifica una classe di cui non \u00E8 possibile creare un''istanza: "{1}". Per i dettagli, vedere l''eccezione successiva.

# Arguments:
#
#    {0} = propertyName
#
X0Y85.S.1=La propriet\u00E0 Derby ''{0}'' identifica una classe che non implementa l''interfaccia org.apache.derby.catalog.SequencePreallocator.

# Arguments:
#
#    {0} = schemaName
#    {1} = sequenceName
#
X0Y86.S=Impossibile ottenere per Derby i blocchi necessari per rilasciare i valori inutilizzati e preallocati per la sequenza ''{0}''.''{1}''. Di conseguenza, in questa sequenza possono apparire intervalli non previsti.

# Arguments:
#
#    {0} = schemaName
#    {1} = aggregateOrFunctionName
#
X0Y87.S=\u00C8 gi\u00E0 presente un''aggregazione o funzione con un argomento denominato ''{0}''.''{1}''.

# Arguments:
#
#    {0} = toolName
#
X0Y88.S=Strumento opzionale sconosciuto: ''{0}''

# Arguments:
#
#    {0} = className
#
X0Y88.S.1=La classe ''{0}'' non implemento l''interfaccia org.apache.derby.iapi.sql.dictionary.OptionalTool.

X0Y89.S=Argomenti non validi passati a SYSCS_UTIL.SYSCS_REGISTER_TOOL(). Consultare la sezione Manuale di riferimento, che descrive questa procedura di sistema.

# Arguments:
#
#    {0} = className
#
X0Y90.S=Impossibile creare un''istanza di {0}. \u00C8 possibile che questa classe non sia visibile nel classpath o che non disponga di un costruttore con 0 argomenti.

# Arguments:
#
#    {0} = constraintName
#
X0Y91.S=Impossibile modificare la modalit\u00E0 di vincolo di {0}. Non \u00E8 un vincolo differibile.

X0Y92.S=Impossibile modificare i nomi delle colonne di questa funzione tabella.

# Arguments:
#
#    {0} = cacheName
#    {1} = keyValue
#
XBCA0.S=Impossibile creare un nuovo oggetto con la chiave {1} nella cache {0}. L''oggetto esiste gi\u00E0 nella cache. 

# Arguments:
#
#    {0} = className
#
XBCM1.S=Errore di collegamento Java restituito durante il caricamento della classe {0} generata.

# Arguments:
#
#    {0} = className
#
XBCM2.S=Impossibile creare un''istanza della classe {0} generata.

# Arguments:
#
#    {0} = className
#    {1} = methodName
#
XBCM3.S=Il metodo {1}() non esiste nella classe {0} generata.

# Arguments:
#
#    {0} = className
#    {1} = limitDescriptor
#
XBCM4.S=Limite del formato file classe Java superato: {1} nella classe generata {0}.

XBCX0.S=Eccezione generata dal provider Crittografia. Per i dettagli, vedere l''eccezione successiva.

XBCX1.S=Inizializzazione della cifratura con modalit\u00E0 non valida, \u00E8 necessario utilizzare la modalit\u00E0 CipherFactory.ENCRYPT o CipherFactory.DECRYPT.

# Arguments:
#
#    {0} = number
#
XBCX2.S=Inizializzazione della crittografia con una password di avvio troppo breve. La password deve avere una lunghezza di almeno {0} caratteri.    

XBCX5.S=Impossibile modificare la password di avvio in un carattere nullo.

XBCX6.S=Impossibile modificare la password di avvio in un tipo serializzabile non di stringa.

XBCX7.S=Formato errato per la modifica della password di avvio. Il formato corretto \u00E8: vecchia_password_avvio, nuova_password_avvio.

XBCX8.S=Impossibile modificare la password di avvio di un database non cifrato.

XBCX9.S=Impossibile modificare la password di avvio di un database di sola lettura.  

XBCXA.S=Password di avvio errata.

# Arguments:
#
#    {0} = paddingDirective
#
XBCXB.S=Spaziatura interna della cifratura ''{0}'' errata o non specificata. \u00C8 necessario utilizzare ''NoPadding''.

# Arguments:
#
#    {0} = algorithmName
#    {1} = providerName
#
XBCXC.S=L''algoritmo di cifratura ''{0}'' non esiste. Verificare che il provider ''{1}'' scelto supporti questo algoritmo.

XBCXD.S=Impossibile modificare l''algoritmo di cifratura dopo la creazione del database.

XBCXE.S=Impossibile modificare il provider di cifratura dopo la creazione del database.

# Arguments:
#
#    {0} = className
#
XBCXF.S=Impossibile trovare la classe ''{0}'' che rappresenta il provider di cifratura.

# Arguments:
#
#    {0} = className
#
XBCXF.S.1=La classe ''{0}'' non implementa l''interfaccia java.security.Provider.

# Arguments:
#
#    {0} = providerName
#
XBCXG.S=Il provider di cifratura ''{0}'' non esiste.

# Arguments:
#
#    {0} = algorithmName
#
XBCXH.S=Il formato di encryptionAlgorithm ''{0}'' non \u00E8 corretto. Il formato corretto \u00E8 algorithm/feedbackMode/NoPadding.

# Arguments:
#
#    {0} = mode
#
XBCXI.S=La modalit\u00E0 feedback ''{0}'' non \u00E8 supportata. Le modalit\u00E0 feedback supportate sono CBC, CFB, OFB e ECB.

XBCXJ.S=L''applicazione sta utilizzando una versione di JCE (Java Cryptography Extension) precedente alla 1.2.1. Aggiornare JCE 1.2.1 e ripetere l''operazione.    

XBCXK.S=La chiave di cifratura fornita non corrisponde alla chiave di cifratura utilizzata durante la creazione del database. Utilizzare la chiave di cifratura corretta e riprovare. 

XBCXL.S=Il processo di verifica per la chiave di cifratura non \u00E8 stato eseguito correttamente. Ci\u00F2 potrebbe essere stato causato da un errore durante l''accesso al file appropriato per eseguire il processo di verifica. Per i dettagli, vedere l''eccezione successiva.  

XBCXM.S=La lunghezza della chiave di cifratura esterna deve corrispondere a un numero pari.

XBCXN.S=La chiave di cifratura esterna contiene uno o pi\u00F9 caratteri non validi. I caratteri consentiti per un numero esadecimale sono 0-9, a-f e A-F.

XBCXO.S=Impossibile cifrare, cifrare di nuovo o decifrare il database quando esiste una transazione globale nello stato preparato.

XBCXQ.S=Impossibile cifrare, cifrare di nuovo o decifrare un database di sola lettura.

XBCXS.S=Impossibile cifrare, cifrare di nuovo o decifrare un database in modalit\u00E0 archivio di log.

# Arguments:
#
#    {0} = failureMessage
#
XBCXU.S=Cifratura, nuova cifratura o decifrazione di un database non riuscita: {0}

# Arguments:
#
#    {0} = algorithmName
#
XBCXW.S=L''algoritmo Message Digest ''{0}'' non \u00E8 supportato da nessuno dei provider di crittografia disponibili. Installare un provider di crittografia che supporta l''algoritmo o specificare un altro algoritmo nella propriet\u00E0 derby.authentication.builtin.algorithm.

XBM01.D=Avvio non riuscito a causa di un''eccezione. Per i dettagli, vedere l''eccezione successiva. 

# Arguments:
#
#    {0} = moduleName
#
XBM02.D=Avvio non riuscito a causa della mancata funzionalit\u00E0 di {0}. Assicurarsi che il classpath comprenda il software Derby corretto.

# Arguments:
#
#    {0} = productName
#
XBM05.D=Avvio non riuscito a causa della non disponibilit\u00E0 delle informazioni sulla versione del prodotto per {0}.

XBM06.D=Avvio non riuscito. Impossibile accedere al database cifrato senza la password di avvio corretta.  

XBM07.D=Avvio non riuscito. La password di avvio deve avere una lunghezza di almeno 8 byte.

# Arguments:
#
#    {0} = subSubProtocol
#    {1} = className
#
XBM08.D=Impossibile creare un''istanza {0} della classe StorageFactory {1}.

# Arguments:
#
#    {0} = directoryName
#    {1} = servicePropertiesName
#
XBM0A.D=La directory del database ''{0}'' esiste, tuttavia non contiene il file ''{1}'' previsto. Derby potrebbe essere stato arrestato durante il processo di creazione del database. Si consiglia di eliminare la directory e provare a ricreare il database.

# Arguments:
#
#    {0} = errorMessage
#
XBM0B.D=Impossibile eseguire operazioni di modifica/scrittura sul file delle propriet\u00E0 del servizio: {0}

# Arguments:
#
#    {0} = operation
#    {1} = path
#    {2} = errorMessage
#
XBM0C.D=Privilegio mancante per l''operazione ''{0}'' sul file ''{1}'': {2}

XBM0G.D=Impossibile avviare il motore di cifratura. Assicurarsi di eseguire Java 2, di aver scaricato un provider di cifratura, ad esempio jce, e di averlo inserito nel classpath. 

# Arguments:
#
#    {0} = directoryName
#
XBM0H.D=Impossibile creare la directory {0}.

# Arguments:
#
#    {0} = directoryName
#
XBM0I.D=Impossibile eliminare la directory {0}.

# Arguments:
#
#    {0} = directoryName
#
XBM0J.D=Directory {0} gi\u00E0 esistente.

# Arguments:
#
#    {0} = databaseName
#
XBM0K.D=Protocollo secondario per il nome database {0} sconosciuto.

# Arguments:
#
#    {0} = className
#    {1} = interfaceName
#
XBM0L.D=La classe {0} specificata dello schema di autenticazione non implementa l''interfaccia di autenticazione {1}.

# Arguments:
#
#    {0} = className
#    {1} = detail
#
XBM0M.D=Errore durante la creazione di un''istanza di una classe denominata ''{0}''. Il nome di questa classe era il valore della propriet\u00E0 derby.authentication.provider ed era previsto come nome di un''implementazione fornita dall''applicazione di org.apache.derby.authentication.UserAuthenticator. Il problema di base era il seguente: {1}

XBM0N.D=Registrazione driver JDBC con java.sql.DriverManager non riuscita. Per i dettagli, vedere l''eccezione successiva. 

XBM0P.D=Il provider di servizi \u00E8 di sola lettura. Operazione non consentita. 

# Arguments:
#
#    {0} = fileName
#
XBM0Q.D=File {0} non trovato. Verificare che la copia di backup sia corretta e che non sia danneggiata.

# Arguments:
#
#    {0} = fileName
#
XBM0R.D=Impossibile eliminare il file {0}.  

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XBM0S.D=Impossibile ridenominare il file ''{0}'' in ''{1}''

# Arguments:
#
#    {0} = databaseName
#
XBM0T.D=Protocollo secondario ambiguo per il nome database {0}.   

# Arguments:
#
#    {0} = identifierName
#
XBM0U.S=Nessuna classe registrata per l''identificativo {0}.

# Arguments:
#
#    {0} = identifierName
#    {1} = className
#
XBM0V.S=\u00C8 stata restituita un''eccezione durante il caricamento della classe {1}, registrata per l''identificativo {0}.

# Arguments:
#
#    {0} = identifierName
#    {1} = className
#
XBM0W.S=\u00C8 stata restituita un''eccezione durante la creazione di un''istanza della classe {1}, registrata per l''identificativo {0}.

# Arguments:
#
#    {0} = localeID
#
XBM0X.D=La descrizione delle impostazioni nazionali ''{0}'' fornita non \u00E8 valida; previsto ln[_CO[_variant]]\nln=codice lingua ISO-639 di due lettere minuscole, CO=codici paese ISO-3166 di due lettere maiuscole, vedere java.util.Locale.

# Arguments:
#
#    {0} = collationName
#
XBM03.D=Il valore fornito ''{0}'' per l''attributo di ordinamento non \u00E8 valido, i valori ammessi sono UCS_BASIC o TERRITORY_BASED.

# Arguments:
#
#    {0} = localeName
#
XBM04.D=Supporto dell''ordinamento non disponibile in JVM per le impostazioni nazionali del database ''{0}''.

# Arguments:
#
#    {0} = directoryName
#
XBM0Y.D=Directory del database di backup {0} non trovata. Verificare che il percorso del backup specificato sia corretto.

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XBM0Z.D=Impossibile copiare il file ''{0}'' in ''{1}''. Verificare di disporre dello spazio necessario e delle autorizzazioni richieste. 

XBDA0.C.1=Timeout di login superato.

# Arguments:
#
#    {0} = operationName
#
XCL01.S=Il set di risultati non restituisce righe. Operazione {0} non consentita. 

# Arguments:
#
#    {0} = operationName
#
XCL05.S=Attivazione chiusa, operazione {0} non consentita.

# Arguments:
#
#    {0} = cursorName
#
XCL07.S=Cursore ''{0}'' chiuso. Verificare che il commit automatico sia inattivo.

# Arguments:
#
#    {0} = cursorName
#
XCL08.S=Il cursore ''{0}'' non si trova su una riga.

# Arguments:
#
#    {0} = methodName
#
XCL09.S=\u00C8 stata inoltrata un''attivazione al metodo ''{0}'' che non corrisponde a PreparedStatement.

XCL10.S=\u00C8 stata ricompilata una PreparedStatement e i parametri sono stati modificati. Se si sta utilizzando JDBC, \u00E8 necessario preparare nuovamente l''istruzione.  

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
XCL12.S=\u00C8 stato effettuato un tentativo di inserire un valore dati di tipo ''{0}'' in uno di tipo ''{1}''.

# Arguments:
#
#    {0} = parameterPosition
#    {1} = number
#
XCL13.S=La posizione del parametro ''{0}'' non \u00E8 compresa nell''intervallo. Il numero dei parametri per questa istruzione preparata \u00E8 ''{1}''.

# Arguments:
#
#    {0} = columnPosition
#    {1} = number
#
XCL14.S=La posizione della colonna ''{0}'' non \u00E8 compresa nell''intervallo. Il numero di colonne per ResultSet \u00E8 ''{1}''.

# Arguments:
#
#    {0} = object
#    {1} = className
#
XCL15.S=Si \u00E8 verificata una ClassCastException durante la chiamata del metodo compareTo() su un oggetto ''{0}''. Il parametro sul metodo compareTo() \u00E8 di classe ''{1}''.

# Arguments:
#
#    {0} = operation
#
XCL16.S=ResultSet non aperto. L''operazione ''{0}'' non \u00E8 consentita. Verificare che il commit automatico sia inattivo.

XCL18.S=Valore LOB o flusso non recuperabile pi\u00F9 di una volta

# Arguments:
#
#    {0} = tableName
#    {1} = key
#
XCL19.S=Riga mancante nella tabella ''{0}'' per la chiave ''{1}''.

# Arguments:
#
#    {0} = versionNumber
#    {1} = versionNumber
#
XCL20.S=Impossibile aggiornare i cataloghi di livello di versione ''{0}'' al livello di versione ''{1}''.

XCL21.S=Si sta tentando di eseguire un''istruzione di definizione dati (CREATE, DROP, o ALTER) durante la preparazione di un''istruzione differente. Ci\u00F2 non \u00E8 consentito. Ci\u00F2 pu\u00F2 verificarsi se si esegue un''istruzione di definizione dati da un inizializzatore statico di una classe Java, utilizzata da un''istruzione SQL.

# Arguments:
#
#    {0} = parameterName
#
XCL22.S=Il parametro {0} non pu\u00F2 essere registrato come parametro OUT perch\u00E9 \u00E8 un parametro IN. 

# Arguments:
#
#    {0} = type
#
XCL23.S=Numero tipo SQL ''{0}'' non supportato da registerOutParameter().

# Arguments:
#
#    {0} = parameterName
#    {1} = type
#
XCL24.S=Il parametro {0} compare come un parametro di output ma non \u00E8 stato definito in questo modo da registerOutParameter(). Se non \u00E8 un parametro di output, deve essere impostato sul tipo {1}.

# Arguments:
#
#    {0} = parameterName
#    {1} = type
#    {2} = type
#
XCL25.S=Il parametro {0} non pu\u00F2 essere registrato come di tipo {1} poich\u00E9 \u00E8 mappato sul tipo {2} e questi non sono compatibili.

# Arguments:
#
#    {0} = parameterName
#
XCL26.S=Il parametro {0} non \u00E8 un parametro di output.

XCL27.S=Impossibile impostare i parametri output di ritorno.

# Arguments:
#
#    {0} = dataType
#
XCL30.S=\u00C8 stata restituita una IOException durante la lettura di ''{0}'' da InputStream.

XCL31.S=Istruzione chiusa.

# Arguments:
#
#    {0} = tableName
#
XCL33.S=Impossibile definire la tabella come dipendente della tabella {0} a causa delle limitazioni imposte dalle regole di eliminazione. La relazione \u00E8 a riferimento automatico e una relazione a riferimento automatico esiste gi\u00E0 con la regola di eliminazione SET NULL. 

# Arguments:
#
#    {0} = tableName
#
XCL34.S=Impossibile definire la tabella come dipendente della tabella {0} a causa delle limitazioni imposte dalle regole di eliminazione. La relazione forma un ciclo di due o pi\u00F9 tabelle che eliminano la tabella o la collegano con s\u00E9 stessa (tutte le altre regole di eliminazione nel ciclo dovrebbero essere CASCADE).  

# Arguments:
#
#    {0} = tableName
#
XCL35.S=Impossibile definire la tabella come dipendente della tabella {0} a causa delle limitazioni imposte dalle regole di eliminazione. La relazione elimina la tabella o la collega alla tabella indicata tramite relazioni multiple e la regola di eliminazione della relazione esistente \u00E8 SET NULL.  

# Arguments:
#
#    {0} = sqlText
#
XCL36.S=La regola di eliminazione della chiave esterna deve essere ''{0}''. Il vincolo referenziale \u00E8 a riferimento automatico e un vincolo a riferimento automatico gi\u00E0 esistente ha la regola di eliminazione indicata (NO ACTION, RESTRICT o CASCADE).

# Arguments:
#
#    {0} = sqlText
#
XCL37.S=La regola di eliminazione della chiave esterna deve essere ''{0}''. Il vincolo referenziale \u00E8 a riferimento automatico e la tabella \u00E8 dipendente in una relazione con una regola di eliminazione CASCADE.

# Arguments:
#
#    {0} = ruleName
#
XCL38.S=La regola di eliminazione della chiave esterna deve essere {0}. La relazione potrebbe eliminare la tabella o collegarla alla stessa tabella tramite relazioni multiple e tali relazioni devono avere la stessa regola di eliminazione (NO ACTION, RESTRICT o CASCADE). 

XCL39.S=La regola di eliminazione della chiave esterna non pu\u00F2 essere CASCADE. Un vincolo di riferimento automatico esiste con una regola di eliminazione SET NULL, NO ACTION o RESTRICT. 

XCL40.S=La regola di eliminazione della chiave esterna non pu\u00F2 essere CASCADE. La relazione potrebbe formare un ciclo che elimina la tabella o la collega a s\u00E9 stessa. Una delle regole di eliminazione esistenti non \u00E8 CASCADE; questa relazione pu\u00F2 essere definibile se la regola di eliminazione non \u00E8 CASCADE. 

XCL41.S=La regola di eliminazione della chiave esterna non pu\u00F2 essere CASCADE. La relazione potrebbe eliminare un''altra tabella o collegarla alla stessa tabella tramite percorsi multipli con diverse regole di eliminazione o con la regola di eliminazione uguale a SET NULL. 

# Arguments:
#
#    {0} = sqlText
#    {1} = versionNumber
#    {2} = versionNumber
#
XCL47.S=Per utilizzare ''{0}'', aggiornare il database passando dalla versione {1} alla versione {2} o successiva.

# Arguments:
#
#    {0} = tableName
#
XCL48.S= TRUNCATE TABLE non \u00E8 consentito in ''{0}'' perch\u00E9 i vincoli di chiave univoca/primaria in questa tabella vengono indicati abilitando i vincoli di chiave esterne da altre tabelle. 

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
XCL49.S= TRUNCATE TABLE non \u00E8 consentito in ''{0}'' perch\u00E9 il trigger DELETE \u00E8 stato abilitato ({1}).

# Arguments:
#
#    {0} = versionNumber
#    {1} = versionNumber
#
XCL50.S=L''aggiornamento del database da una versione precedente non \u00E8 supportato. Il database a cui si accede \u00E8 al livello della versione ''{0}'', il software \u00E8 al livello della versione ''{1}''.    

XCL51.S=La funzione richiesta non pu\u00F2 fare riferimento alle tabelle nello schema SESSION.

XCL52.S=L''istruzione \u00E8 stata annullata o si \u00E8 verificato il timeout.

# Arguments:
#
#    {0} = versionID
#    {1} = versionID
#
XCW00.D=Aggiornamento da ''{0}'' a ''{1}'' non supportato.

XCXA0.S=Identificativo non valido.

# Arguments:
#
#    {0} = classpath
#
XCXB0.S=Classpath database non valido: ''{0}''.

XCXC0.S=Lista ID non valida.

XCXE0.S=Si sta tentando di eseguire un''operazione che dovrebbe utilizzare le impostazioni nazionali del database, ma il database non dispone di impostazioni nazionali.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCY00.S=Valore non valido per la propriet\u00E0 ''{0}''=''{1}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCY02.S=La modifica della propriet\u00E0 richiesta non \u00E8 supportata ''{0}''=''{1}''.

# Arguments:
#
#    {0} = propertyName
#
XCY03.S=Propriet\u00E0 richiesta ''{0}'' non impostata.

XCY04.S=Sintassi non valida per le sostituzioni dell''ottimizzatore. La sintassi deve essere -- DERBY-PROPERTIES propertyName = value [, propertyName = value]*

XCY05.S.2=Impostazione non valida della propriet\u00E0 derby.authentication.provider. Questa propriet\u00E0 \u00E8 gi\u00E0 impostata per abilitare l''autenticazione NATIVE e non pu\u00F2 essere modificata.

XCY05.S.3=Impostazione non valida della propriet\u00E0 derby.authentication.provider. Per abilitare l''autenticazione NATIVE, usare la procedura SYSCS_UTIL.SYSCS_CREATE_USER per memorizzare le credenziali del proprietario del database.

# Arguments:
#
#    {0} = permissionName
#
XCZ00.S=Autorizzazione sconosciuta ''{0}''.

# Arguments:
#
#    {0} = authorizationID
#
XCZ01.S=Utente sconosciuto ''{0}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCZ02.S=Parametro non valido ''{0}''=''{1}''.

XD004.S=Impossibile memorizzare le dipendenze.

XIE01.S=Connessione nulla.

# Arguments:
#
#    {0} = lineNumber
#    {1} = columnName
#
XIE03.S=Dati trovati sulla riga {0} della colonna {1} dopo il delimitatore di arresto.  

# Arguments:
#
#    {0} = fileName
#
XIE04.S=File dati non trovato: {0}

XIE05.S=Il file di dati non pu\u00F2 essere nullo. 

XIE06.S=Nome entit\u00E0 nullo.

XIE07.S=I separatori di campo e record non possono essere sottostringhe uno dell''altro. 

# Arguments:
#
#    {0} = columnName
#
XIE08.S=Non esiste alcuna colonna denominata: {0}.  

# Arguments:
#
#    {0} = number
#
XIE09.S=Il numero totale delle colonne presenti nella riga \u00E8: {0}.  

# Arguments:
#
#    {0} = columnName
#    {1} = type
#
XIE0B.S=La colonna ''{0}'' della tabella \u00E8 di tipo {1} e non \u00E8 supportata dalla funzione di importazione/esportazione.   

# Arguments:
#
#    {0} = lineNumber
#
XIE0D.S=Impossibile trovare il separatore di record sulla riga {0}.

# Arguments:
#
#    {0} = lineNumber
#
XIE0E.S=Carattere di fine file riscontrato in una posizione non prevista alla riga {0}.

XIE0I.S=Riscontrata IOException durante la scrittura dei dati sul file.

XIE0J.S=Un delimitatore non \u00E8 valido o viene utilizzato pi\u00F9 di una volta.

XIE0K.S=Il punto \u00E8 stato specificato come delimitatore di una stringa di caratteri.

# Arguments:
#
#    {0} = tableName
#
XIE0M.S=La tabella ''{0}'' non esiste.  

# Arguments:
#
#    {0} = hexString
#
XIE0N.S=\u00C8 stata rilevata una stringa esadecimale non valida, ''{0}'', nel file di importazione.

# Arguments:
#
#    {0} = fileName
#
XIE0P.S=Impossibile trovare il file di dati lob {0} referenziato nel file di importazione.

XIE0Q.S=Il nome del file di dati lob non pu\u00F2 essere nullo. 

# Arguments:
#
#    {0} = lineNumber
#    {1} = fileName
#    {2} = details
#
XIE0R.S=Errore di importazione alla riga {0} del file {1}: {2} 

# Arguments:
#
#    {0} = fileName
#
XIE0S.S=L''operazione di esportazione non \u00E8 stata eseguita in quanto il file di output specificato ({0}) esiste gi\u00E0. L''operazione di esportazione non sovrascrive i file esistenti anche quando il processo dispone delle necessarie autorizzazioni in scrittura, per ragioni di sicurezza e per impedire la perdita accidentale di dati. Modificare il nome del file di output negli argomenti della procedura di esportazione oppure eliminare il file esistente e quindi ritentare la procedura.

# Arguments:
#
#    {0} = fileName
#
XIE0T.S=L''operazione di esportazione non \u00E8 stata eseguita in quanto il file lob ausiliario specificato ({0}) esiste gi\u00E0. L''operazione di esportazione non sovrascrive i file esistenti anche quando il processo dispone delle necessarie autorizzazioni in scrittura, per ragioni di sicurezza e per impedire la perdita accidentale di dati. Modificare il nome del file lob ausiliario negli argomenti della procedura di esportazione oppure eliminare il file esistente e quindi ritentare la procedura.

# Arguments:
#
#    {0} = databaseName
#
XJ004.C=Database ''{0}'' non trovato.

XJ008.S=Impossibile eseguire il rollback o il rilascio di un savepoint in modalit\u00E0 di commit automatico.

# Arguments:
#
#    {0} = sqlText
#
XJ009.S=Utilizzo di CallableStatement richiesto per la chiamata della stored procedure o utilizzo dei parametri di output: {0}

XJ010.S=Impossibile eseguire SAVEPOINT quando autoCommit \u00E8 attivo.

XJ011.S=Impossibile passare un valore nullo per il nome di SAVEPOINT.

# Arguments:
#
#    {0} = interfaceName
#
XJ012.S=''{0}'' gi\u00E0 chiuso.

XJ013.S=Nessun identificativo per i SAVEPOINT denominati.

XJ014.S=Nessun nome per i SAVEPOINT non denominati.

XJ015.M=Arresto sistema Derby.

# Arguments:
#
#    {0} = methodName
#
XJ016.S=Metodo ''{0}'' non consentito sull''istruzione preparata.

XJ017.S=Nessun comando savepoint consentito all''interno del codice trigger.

XJ018.S=Il nome colonna non pu\u00F2 essere nullo.

# Arguments:
#
#    {0} = typeName
#
XJ020.S=Tipo di oggetto non convertibile in tipo ''{0}'', valore java.sql.Types non valido o oggetto nullo.

XJ021.S=Tipo non supportato.

# Arguments:
#
#    {0} = name
#
XJ022.S=Impossibile impostare il flusso: ''{0}''.

XJ023.S=Il flusso di input non disponeva della quantit\u00E0 esatta di dati della lunghezza richiesta.

XJ025.S=Il flusso di input non pu\u00F2 avere una lunghezza negativa.

# Arguments:
#
#    {0} = urlValue
#
XJ028.C=URL ''{0}'' non formato correttamente.

XJ030.S=Impossibile impostare Autocommit On in una connessione nidificata.

# Arguments:
#
#    {0} = databaseName
#    {1} = classLoader
#
XJ040.C=Impossibile avviare il database ''{0}'' con il caricatore di classi {1}. Per i dettagli, vedere l''eccezione successiva.

# Arguments:
#
#    {0} = databaseName
#
XJ041.C=Impossibile creare il database ''{0}''; per i dettagli, vedere l''eccezione successiva.

# Arguments:
#
#    {0} = propertyValue
#    {1} = propertyName
#
XJ042.S=''{0}'' non \u00E8 un valore valido per la propriet\u00E0 ''{1}''.

# Arguments:
#
#    {0} = number
#
XJ044.S=''{0}'' non \u00E8 una scala valida.

# Arguments:
#
#    {0} = levelName
#
XJ045.S=Livello di isolamento non valido o attualmente non supportato, ''{0}'', passato a Connection.setTransactionIsolation(). I valori supportati sono java.sql.Connection.TRANSACTION_SERIALIZABLE, java.sql.Connection.TRANSACTION_REPEATABLE_READ, java.sql.Connection.TRANSACTION_READ_COMMITTED e java.sql.Connection.TRANSACTION_READ_UNCOMMITTED.

# Arguments:
#
#    {0} = attributes
#
XJ048.C=Sono stati specificati attributi di avvio in conflitto: {0}

XJ049.C=Conflitto durante la creazione degli attributi specificati.

XJ04B.S=Il batch non pu\u00F2 contenere un comando che tenti di restituire un set di risultati.

XJ04C.S=Il batch CallableStatement non pu\u00F2 contenere i parametri di output.

XJ056.S=Impossibile impostare Autocommit On in una connessione XA.

XJ057.S=Impossibile eseguire l''operazione di commit di una transazione globale utilizzando la Connessione;, l''elaborazione del commit deve essere eseguita attraverso l''interfaccia XAResource.

XJ058.S=Impossibile eseguire l''operazione di rollback di una transazione globale utilizzando la Connessione; l''elaborazione del commit deve essere eseguita attraverso l''interfaccia XAResource.

XJ059.S=Impossibile chiudere una connessione mentre una transazione globale \u00E8 ancora attiva.

# Arguments:
#
#    {0} = attributeName
#    {1} = attributeValue
#    {2} = attributeValues
#
XJ05B.C=L''attributo JDBC ''{0}'' ha un valore non valido ''{1}'', i valori validi sono ''{2}''.

XJ05C.S=Impossibile impostare holdability ResultSet.HOLD_CURSORS_OVER_COMMIT per una transazione globale.

# Arguments:
#
#    {0} = methodName
#
XJ061.S=Il metodo ''{0}'' \u00E8 consentito solo sui cursori di scorrimento.

# Arguments:
#
#    {0} = invalidNumber
#
XJ062.S=Valore parametro ''{0}'' non valido per ResultSet.setFetchSize(int rows).

# Arguments:
#
#    {0} = invalidNumber
#
XJ063.S=Valore parametro ''{0}'' non valido per Statement.setMaxRows(int maxRows). Il valore del parametro deve essere >= 0.

# Arguments:
#
#    {0} = invalidNumber
#
XJ064.S=Valore parametro ''{0}'' non valido per setFetchDirection(int direction).

# Arguments:
#
#    {0} = invalidNumber
#
XJ065.S=Valore parametro ''{0}'' non valido per Statement.setFetchSize(int rows).

# Arguments:
#
#    {0} = invalidNumber
#
XJ066.S=Valore parametro ''{0}'' non valido per Statement.setMaxFieldSize(int max).

XJ067.S=Il puntatore di testo SQL \u00E8 nullo.

XJ068.S=Solo executeBatch e clearBatch sono consentiti durante un batch.

XJ069.S=Nessun metodo SetXXX consentito in caso di USING execute statement.

# Arguments:
#
#    {0} = argument
#
XJ070.S=Argomento posizione negativo o nullo ''{0}'' passato in un metodo Blob o Clob.

# Arguments:
#
#    {0} = argument
#
XJ071.S=Argomento lunghezza negativo ''{0}'' passato a un metodo BLOB o CLOB.

XJ072.S=Pattern nullo o searchStr passato a un metodo di posizione BLOB o CLOB.

XJ073.S=I dati presenti nel metodo BLOB o CLOB non sono pi\u00F9 disponibili. La transazione BLOB/CLOB potrebbe essere stata completata, la relativa connessione potrebbe essere chiusa oppure \u00E8 stata liberata.

# Arguments:
#
#    {0} = invalidNumber
#
XJ074.S=Valore del parametro ''{0}'' non valido per Statement.setQueryTimeout(int seconds).

# Arguments:
#
#    {0} = positionArgument
#
XJ076.S=L''argomento posizione ''{0}'' supera la dimensione di BLOB/CLOB.

XJ077.S=\u00C8 stata riscontrata un''eccezione durante il tentativo di leggere il primo byte/carattere del pattern BLOB/CLOB utilizzando getBytes/getSubString.

# Arguments:
#
#    {0} = invalidNumber
#
XJ078.S=L''offset ''{0}'' \u00E8 inferiore a zero o troppo grande per il BLOB/CLOB corrente.

# Arguments:
#
#    {0} = number
#
XJ079.S=La lunghezza specificata ''{0}'' supera la dimensione di BLOB/CLOB.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ080.S=USING execute statement ha passato {0} parametri invece di ''{1}''.

XJ081.C=Sono stati specificati degli attributi di creazione/ripristino/recupero in conflitto.

# Arguments:
#
#    {0} = parameterValue
#    {1} = parameterName
#    {2} = methodName
#
XJ081.S=Valore ''{0}'' non valido inviato come parametro ''{1}'' al metodo ''{2}''

XJ085.S=Il flusso \u00E8 stato gi\u00E0 letto, \u00E8 stata raggiunta la fine del file e non \u00E8 possibile riutilizzarlo.

XJ086.S=Non \u00E8 possibile richiamare questo metodo mentre il cursore non si trova sulla riga di inserimento oppure se la simultaneit\u00E0 di questo oggetto ResultSet \u00E8 CONCUR_READ_ONLY.

# Arguments:
#
#    {0} = pos
#    {1} = length
#
XJ087.S=La somma della posizione (''{0}'') e della lunghezza (''{1}'') produce un valore superiore alla dimensione del LOB pi\u00F9 uno.

XJ088.S=Operazione non valida: wasNull() \u00E8 stato chiamato senza alcun dato recuperato.

XJ090.S=Parametro non valido: il calendario \u00E8 nullo.

# Arguments:
#
#    {0} = indexNumber
#
XJ091.S=Argomento non valido: l''indice del parametro {0} non \u00E8 un parametro OUT o INOUT.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ093.S=La lunghezza di BLOB/CLOB, {0}, \u00E8 troppo grande. Non pu\u00F2 superare {1}.

XJ095.S=Tentativo di eseguire un''azione privilegiata non riuscito.

XJ097.S=Impossibile eseguire il rollback o il rilascio di un savepoint creato da questa connessione.

# Arguments:
#
#    {0} = keyValue
#
XJ098.S=Valore delle chiavi generato automaticamente {0} non valido

XJ099.S=L''oggetto Reader/Stream non contiene i caratteri di lunghezza

XJ100.S=La scala fornita dal metodo registerOutParameter non corrisponde al metodo setter. Possibile perdita di precisione.

XJ103.S=Il nome della tabella non pu\u00F2 essere nullo

# Arguments:
#
#    {0} = invalidNumber
#
XJ104.S=Lunghezza chiave condivisa non valida: {0}.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ105.S=La lunghezza della chiave DES non \u00E8 corretta, lunghezza prevista {0}, lunghezza acquisita {1}.

XJ106.S=Nessuna spaziatura interna 

XJ107.S=Spaziatura interna non valida

XJ108.S=Dimensione blocco non valida

XJ110.S=Il nome della tabella primaria non pu\u00F2 essere nullo

XJ111.S=Il nome della tabella esterna non pu\u00F2 essere nullo

XJ112.S=Si \u00E8 verificata un''eccezione di sicurezza; per i dettagli, vedere l''eccezione successiva.

# Arguments:
#
#    {0} = fileName
#    {1} = error
#
XJ113.S=Impossibile aprire il file {0} : {1}

# Arguments:
#
#    {0} = cursorName
#
XJ114.S=Nome cursore non valido ''{0}''

# Arguments:
#
#    {0} = invalidNumber
#
XJ115.S=Impossibile aprire resultSet con holdability richiesto {0}.

# Arguments:
#
#    {0} = number
#
XJ116.S=Non \u00E8 possibile aggiungere pi\u00F9 di {0} comandi a un singolo batch.

XJ117.S=Batch di query non consentito dalla compatibilit\u00E0 J2EE.

XJ118.S=Batch di query richiesto su un''istruzione non di query.

XJ121.S=Operazione non valida alla posizione del cursore corrente.

XJ122.S=Nessun metodo updateXXX \u00E8 stato richiamato su questa riga.

XJ123.S=Questo metodo deve essere richiamato per aggiornare i valori nella riga corrente o nella riga di inserimento.

XJ124.S=Colonna non aggiornabile.

XJ125.S=Questo metodo deve essere richiamato solo su oggetti ResultSet scorrevoli (tipo TYPE_SCROLL_INSENSITIVE).

XJ126.S=Questo metodo non deve essere richiamato su cursori dinamici sensibili.

# Arguments:
#
#    {0} = interfaceName
#
XJ128.S=Impossibile annullare il ritorno a capo per ''{0}''

# Arguments:
#
#    {0} = number
#
XJ200.S=Numero massimo di sezioni {0} superato

# Arguments:
#
#    {0} = cursorName
#
XJ202.S=Nome cursore non valido ''{0}''.

# Arguments:
#
#    {0} = cursorName
#
XJ203.S=Nome cursore ''{0}'' gi\u00E0 in uso

# Arguments:
#
#    {0} = holdValue
#
XJ204.S=Impossibile aprire il set di risultati con holdability richiesto {0}.

# Arguments:
#
#    {0} = sqlText
#
XJ206.S=Il testo SQL ''{0}'' non dispone di token.

XJ207.S=Impossibile utilizzare il metodo executeQuery per l''aggiornamento.

XJ208.S=Batch non atomico non riuscito. Il batch \u00E8 stato sottomesso, ma si \u00E8 verificata almeno un''eccezione su un membro singolo del batch. Utilizzare getNextException() per recuperare le eccezioni per gli elementi specifici di cui \u00E8 stato eseguito il batch.

XJ209.S=La stored procedure richiesta non \u00E8 installata sul server.

XJ210.S=Non \u00E8 stato trovato il nome del modulo di caricamento per la stored procedure sul server.

XJ211.S=Si \u00E8 verificata un''eccezione di interruzione della catena irreversibile durante l''elaborazione batch. L''elaborazione batch \u00E8 stata interrotta non atomicamente.

# Arguments:
#
#    {0} = attributeSyntax
#
XJ212.S=Sintassi dell''attributo non valida: {0}

XJ213.C=La propriet\u00E0 di connessione traceLevel non dispone di un formato valido per un numero.

XJ214.S=Si \u00E8 verificato un errore IO durante la chiamata di free() su un CLOB o BLOB.

XJ215.S=Non \u00E8 possibile richiamare altri metodi java.sql.Clob/java.sql.Blob dopo una chiamata al metodo free() oppure dopo che la transazione Blob/Clob \u00E8 stata confermata o che ne \u00E8 stato eseguito il rollback.

XJ216.S=La lunghezza dell''oggetto BLOB/CLOB non \u00E8 ancora disponibile. Quando si accede a un oggetto BLOB o CLOB come flusso, la lunghezza non \u00E8 disponibile fino al termine dell''elaborazione dell''intero flusso.

XJ217.S=Il locator fornito per questo oggetto CLOB/BLOB non \u00E8 valido

# Arguments:
#
#    {0} = reason
#
XK000.S=Impossibile ricaricare i criteri di sicurezza: {0}

XK001.S=Nome utente non trovato in SYS.SYSUSERS.

XN001.S=Reimpostazione della connessione non consentita all''interno di un''unit\u00E0 di lavoro.

XN008.S=Elaborazione della query terminata a causa di un errore sul server.

XN009.S=Errore relativo alla lunghezza dell''oggetto BLOB/CLOB, segue eccezione.

XN010.S=Il nome della procedura non pu\u00F2 essere nullo.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XN011.S=La lunghezza del nome della procedura {0} non \u00E8 compresa nell''intervallo valido da 1 a {1}.

# Arguments:
#
#    {0} = operatingSystemName
#    {1} = versionNumber
#    {2} = versionNumber
#
XN012.S=Su piattaforme {0}, XA supporta la versione {1} e successive, questa \u00E8 la versione {2}

XN013.S=Orientamento di scorrimento non valido.

# Arguments:
#
#    {0} = number
#    {1} = messageText
#
XN014.S=Si \u00E8 verificata un''eccezione durante la lettura del flusso specificato dal parametro #{0}. I dati restanti previsti dal server sono stati riempiti con 0x0. \u00C8 stata visualizzata l''eccezione seguente: {1}.

# Arguments:
#
#    {0} = number
#
XN015.S=Errore del protocollo di rete: la dimensione specificata di InputStream, parametro #{0}, \u00E8 inferiore alla lunghezza reale di InputStream.

# Arguments:
#
#    {0} = number
#    {1} = messageText
#
XN016.S=Si \u00E8 verificata un''eccezione durante il tentativo di verificare la lunghezza del flusso specificato dal parametro #{0}. \u00C8 stata visualizzata l''eccezione seguente: {1}.

# Arguments:
#
#    {0} = number
#
XN017.S=Interruzione del flusso anomala durante la lettura del flusso specificato dal parametro #{0}. I dati restanti previsti dal server sono stati riempiti con 0x0.

# Arguments:
#
#    {0} = number
#
XN018.S=Errore del protocollo di rete: la dimensione specificata di Reader, parametro #{0}, \u00E8 inferiore alla lunghezza reale di InputStream.

# Arguments:
#
#    {0} = xaFunctionName
#    {1} = xaError
#
XN019.S=Errore durante l''esecuzione di {0}, il server ha restituito {1}.

# Arguments:
#
#    {0} = messageDetail
#
XN020.S=Errore durante il marshalling o l''unmarshalling di un tipo definito dall''utente: {0}

# Arguments:
#
#    {0} = sourceClassName
#    {1} = targetClassName
#
XN021.S=Impossibile associare un oggetto di tipo {0} a un oggetto di tipo {1}.

XN022.C=Impossibile reimpostare una catena di scritture che ha trasmesso dati al server finch\u00E9 la richiesta non sar\u00E0 finita e la catena terminata.

# Arguments:
#
#    {0} = number
#
XN023.C=Il flusso specificato dal parametro #{0} \u00E8 basato sul locator e richiede una richiesta nidificata nella stessa connessione da materializzare. Ci\u00F2 non \u00E8 supportato.

# Arguments:
#
#    {0} = number
#    {1} = messageText
#
XN024.C=Si \u00E8 verificata un''eccezione che ha interrotto la connessione durante la lettura dal flusso specificato dal parametro #{0}. Messaggio dell''eccezione: {1}.

XRE00=Il modulo LogFactory non supporta la replica.

XRE01=Il log ricevuto dal master \u00E8 danneggiato.

XRE02=Le versioni di master e slave non corrispondono. Impossibile procedere con la replica.

XRE03=Errore di replica imprevisto. Per i dettagli, vedere derby.log.

# Arguments:
#
#    {0} = dbname
#    {1} = hostname
#    {2} = portname
#
XRE04.C.1=Impossibile stabilire una connessione al peer del database replicato ''{0}'' sull''indirizzo ''{1}:{2}''.

# Arguments:
#
#    {0} = dbname
#
XRE04.C.2=Connessione interrotta per il database replicato ''{0}''.

# Arguments:
#
#    {0} = dbname
#    {1} = masterfile
#    {2} = masteroffset
#    {3} = slavefile
#    {4} = slaveoffset
#
XRE05.C=I file di log su master e slave non sono in sincronia per il database replicato ''{0}''. La classe instant del log del master \u00E8 {1}:{2}, mentre quella del log dello slave \u00E8 {3}:{4}. Si tratta di un errore irreversibile per la replica che viene interrotta.

# Arguments:
#
#    {0} = dbname
#
XRE06=I tentativi di connessione allo slave di replica per il database {0} eccedono il periodo di timeout specificato.

XRE07=Impossibile eseguire l''operazione poich\u00E9 il database non \u00E8 in modalit\u00E0 master di replica.

# Arguments:
#
#    {0} = dbname
#
XRE08=Modalit\u00E0 slave di replica avviata correttamente per il database ''{0}''. Connessione rifiutata perch\u00E9 il database \u00E8 in modalit\u00E0 slave di replica. 

# Arguments:
#
#    {0} = dbname
#
XRE09.C=Impossibile avviare la modalit\u00E0 slave di replica per il database ''{0}''. Il database \u00E8 gi\u00E0 stato avviato.

# Arguments:
#
#    {0} = attribute
#
XRE10=Attributi specificati in conflitto. Per gli attributi consentiti in combinazione con l''attributo di replica ''{0}'', vedere la documentazione di riferimento.

# Arguments:
#
#    {0} = command
#    {1} = dbname
#
XRE11.C=Impossibile eseguire l''operazione ''{0}'' perch\u00E9 il database ''{1}'' non \u00E8 stato avviato.

# Arguments:
#
#    {0} = dbname
#    {1} = expectedtype
#    {2} = receivedtype
#
XRE12=Errore del protocollo di rete durante la replica per il database ''{0}''. Tipo di messaggio previsto: ''{1}'', tipo di messaggio ricevuto: ''{2}''.

# Arguments:
#
#    {0} = dbname
#
XRE20.D=Failover eseguito correttamente per il database ''{0}'', il database \u00E8 stato arrestato.

# Arguments:
#
#    {0} = dbname
#
XRE21.C=Si \u00E8 verificato un errore durante l''esecuzione del failover per il database ''{0}''. Il tentativo di failover \u00E8 stato interrotto.

# Arguments:
#
#    {0} = dbname
#
XRE22.C=Il master di replica \u00E8 gi\u00E0 stato avviato per il database ''{0}''

XRE23=Impossibile avviare il master di replica perch\u00E9 sono in corso operazioni non registrate. Per consentire il completamento delle operazioni e riavviare la replica, eseguire uno sblocco.

XRE40=Impossibile eseguire l''operazione poich\u00E9 il database non \u00E8 in modalit\u00E0 slave di replica.

XRE41.C=Operazione di replica ''failover'' o ''stopSlave'' rifiutata nel database slave perch\u00E9 la connessione con il master \u00E8 attiva. Eseguire l''operazione ''failover'' o ''stopMaster'' sul database master.

# Arguments:
#
#    {0} = dbname
#
XRE42.C=Arresto database replicato ''{0}''.

XRE43=Errore imprevisto durante il tentativo di arrestare la modalit\u00E0 slave di replica. Per interrompere la modalit\u00E0 slave di replica, usare l''operazione ''stopSlave o ''failover''.

# Arguments:
#
#    {0} = conglomerateNumber
#
XSAI2.S=Il conglomerato ({0}) richiesto non esiste.

XSAI3.S=Funzione non implementata.

# Arguments:
#
#    {0} = interfaceName
#
XSAM0.S=Eccezione riscontrata durante il tentativo di avviare il modulo per ''{0}''.

# Arguments:
#
#    {0} = conglomID
#
XSAM2.S=Non esistono indici o conglomerati con ID conglomerato ''{0}'' da eliminare.

# Arguments:
#
#    {0} = conglomID
#
XSAM3.S=Non esistono indici o conglomerati con ID conglomerato ''{0}''.

# Arguments:
#
#    {0} = sortName
#
XSAM4.S=Non esiste alcun ordinamento denominato ''{0}''.

XSAM5.S=\u00C8 necessario aprire e posizionare una scansione chiamando next() prima di eseguire altre chiamate.

# Arguments:
#
#    {0} = containerName
#    {1} = pageNumber
#    {2} = recordNumber
#
XSAM6.S=Il record {2} sulla pagina {1} nel contenitore {0} non \u00E8 stato trovato.

XSAS0.S=\u00C8 stato chiamato un metodo interfaccia controller di scansione non appropriato per una scansione su un ordinamento.

XSAS1.S=\u00C8 stato effettuato un tentativo di lettura in sequenza di una riga prima dell''avvio o al termine di un ordinamento.

XSAS3.S=Il tipo di riga inserita in un ordinamento non corrisponde al modello dell''ordinamento.

XSAS6.S=Impossibile acquisire le risorse per l''ordinamento.

XSAX0.S=Violazione protocollo XA.

XSAX1.S=\u00C8 stato effettuato un tentativo di avvio di una transazione globale con un Xid di una transazione globale esistente.

XSCB0.S=Impossibile creare il contenitore.

# Arguments:
#
#    {0} = containerName
#
XSCB1.S=Il contenitore {0} non \u00E8 stato trovato.

# Arguments:
#
#    {0} = propertyName
#
XSCB2.S=La propriet\u00E0 richiesta {0} non \u00E8 stata trovata nella lista delle propriet\u00E0 fornita a createConglomerate() per un indice secondario btree.

XSCB3.S=Funzione non implementata.

# Arguments:
#
#    {0} = number
#
XSCB4.S=\u00C8 stato chiamato un metodo su una scansione aperta btree prima di posizionare la scansione sulla prima riga (ad esempio, non \u00E8 ancora stata effettuata alcuna chiamata next()). Lo stato corrente della scansione \u00E8 ({0}).

XSCB5.S=Durante l''annullamento logico di un''operazione di inserimento o eliminazione di btree non \u00E8 possibile trovare la riga nella struttura.

XSCB6.S=Limitazione: impossibile aggiornare o inserire il record di un indice secondario btree a causa della mancanza di spazio sulla pagina. Utilizzare i parametri derby.storage.pageSize e/o derby.storage.pageReservedSpace per evitare questa limitazione.

# Arguments:
#
#    {0} = trueOrFalse
#    {1} = trueOrFalse
#
XSCB7.S=\u00C8 stato riscontrato un errore interno durante una scansione btree - current_rh \u00E8 nullo = {0}, la chiave posizione \u00E8 nulla = {1}.

# Arguments:
#
#    {0} = conglomerateNumber
#
XSCB8.S=Il conglomerato btree {0} \u00E8 chiuso.

XSCB9.S=Riservato per scopi di test.

XSCG0.S=Impossibile creare un modello.

XSCH0.S=Impossibile creare il contenitore.

# Arguments:
#
#    {0} = containerName
#
XSCH1.S=Il contenitore {0} non \u00E8 stato trovato.

XSCH4.S=Impossibile creare il conglomerato.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XSCH5.S=In una tabella di base si \u00E8 verificata una mancata corrispondenza tra il numero di colonne richiesto, {0}, e il numero massimo di colonne, {1}.

# Arguments:
#
#    {0} = containerID
#
XSCH6.S=Contenitore heap con ID contenitore {0} chiuso.

XSCH7.S=Scansione non posizionata.

XSCH8.S=Funzione non implementata.

XSDA1.S=\u00C8 stato effettuato un tentativo di accedere a uno slot fuori intervallo su una pagina

XSDA2.S=\u00C8 stato effettuato un tentativo di aggiornare un record eliminato

XSDA3.S=Limitazione: impossibile aggiornare o inserire un record a causa della mancanza di spazio sulla pagina. Utilizzare i parametri derby.storage.pageSize e/o derby.storage.pageReservedSpace per evitare questa limitazione.

XSDA4.S=\u00C8 stata restituita un''eccezione imprevista

XSDA5.S=\u00C8 stato effettuato un tentativo di annullare l''eliminazione di un record non eliminato.

# Arguments:
#
#    {0} = columnName
#
XSDA6.S=La colonna {0} della riga \u00E8 nulla, \u00E8 necessario impostarla per puntare a un oggetto.

# Arguments:
#
#    {0} = className
#
XSDA7.S=Ripristino di un oggetto serializzabile o SQLData della classe {0}; tentativo di leggere una quantit\u00E0 di dati maggiore di quelli memorizzati

# Arguments:
#
#    {0} = className
#
XSDA8.S=Eccezione durante il ripristino di un oggetto serializzabile o SQLData della classe {0}

# Arguments:
#
#    {0} = className
#
XSDA9.S=Classe non trovata durante il ripristino di un oggetto serializzabile o SQLData della classe {0}

# Arguments:
#
#    {0} = timestamp
#
XSDAA.S=Indicatore data/ora {0} non valido, \u00E8 possibile che provenga da una pagina differente o da un''implementazione non compatibile

XSDAB.S=Impossibile impostare un indicatore data/ora nullo.

XSDAC.S=Tentativo di spostare le righe o le pagine da un contenitore a un altro.

XSDAD.S=Tentativo di spostare zero righe da una pagina a un''altra.

XSDAE.S=\u00C8 possibile eseguire un handle di record solo per un ID handle di record speciale.

XSDAF.S=Uso di un handle di record speciale come se fosse normale.

XSDAG.S=Impossibile aprire il contenitore durante l''esecuzione di una transazione interna nidificata che alloca ulteriore spazio a una tabella.

# Arguments:
#
#    {0} = page
#
XSDAI.S=La pagina {0} da eliminare \u00E8 gi\u00E0 bloccata per il rilascio.

XSDAJ.S=Eccezione durante la scrittura di un oggetto serializzabile o SQLData

# Arguments:
#
#    {0} = recordHandle
#
XSDAK.S=Pagina errata richiamata per l''handle di record {0}.

# Arguments:
#
#    {0} = recordHandle
#
XSDAL.S=L''handle di record {0} punta inaspettatamente alla pagina di overflow.

# Arguments:
#
#    {0} = className
#
XSDAM.S=Eccezione durante il ripristino di un oggetto SQLData della classe {0}. Impossibile creare l''istanza della classe specificata.

# Arguments:
#
#    {0} = className
#
XSDAN.S=Eccezione durante il ripristino di un oggetto SQLData della classe {0}. La classe specificata ha rilevato un''eccezione di accesso non valida.

# Arguments:
#
#    {0} = pageNumber
#
XSDAO.S=Errore interno: si sono verificati due tentativi di latch per la pagina {0}.

# Arguments:
#
#    {0} = pageId
#    {1} = pageDump
#    {2} = slot
#    {3} = recordId
#    {4} = columnList
#    {5} = nextColumn
#    {6} = updateMode
#    {7} = nextPortionHandle
#
XSDAP.S=Errore di tipo nessuno spazio disponibile imprevisto durante il tentativo di aggiornare una riga nella pagina {0}. I valori dei campo interni al momento dell''errore erano i seguenti: slot = {2}, recordId = {3}, newColumnList = {4}, nextColumn = {5}, mode = {6}, nextPortionHandle = {7}, page dump = {1}.

# Arguments:
#
#    {0} = page
#
XSDB0.D=Eccezione imprevista sulla pagina in-memoria {0}

# Arguments:
#
#    {0} = page
#
XSDB1.D=Formato pagina sconosciuto alla pagina {0}

# Arguments:
#
#    {0} = containerName
#    {1} = number
#
XSDB2.D=Formato contenitore sconosciuto nel contenitore {0} : {1}

# Arguments:
#
#    {0} = number
#    {1} = number
#
XSDB3.D=Impossibile modificare le informazioni sul contenitore una volta scritte: erano {0}, ora sono {1}

# Arguments:
#
#    {0} = page
#    {1} = versionNumber
#    {2} = versionNumber
#
XSDB4.D=La pagina {0} si trova \u00E8 della versione {1}, il file di log contiene la versione modificata {2}; esistono dei record di log mancanti di questa pagina oppure questa pagina non \u00E8 stata scritta in modo corretto sul disco.

# Arguments:
#
#    {0} = page
#
XSDB5.D=Il log contiene record modifiche sulla pagina {0}, oltre il limite del contenitore.

# Arguments:
#
#    {0} = databaseName
#
XSDB6.D=Un''altra istanza di Derby potrebbe avere avviato il database ''{0}''.

# Arguments:
#
#    {0} = derbyInstanceID
#    {1} = databaseName
#    {2} = derbyInstanceID
#
XSDB7.D=Avvertenza: Derby (istanza {0}) sta tentando di avviare il database {1} anche se Derby (istanza {2}) potrebbe essere ancora attivo. Ogni database deve essere avviato da una singola istanza di Derby. Ci\u00F2 pu\u00F2 determinare un errore grave o irreversibile oppure tale errore potrebbe essersi gi\u00E0 verificato.

# Arguments:
#
#    {0} = derbyInstanceID
#    {1} = databaseName
#    {2} = derbyInstanceID
#
XSDB8.D=Avvertenza: Derby (istanza {0}) sta tentando di avviare il database {1} anche se Derby (istanza {2}) potrebbe essere ancora attivo. Ogni database deve essere avviato da una singola istanza di Derby. Se due istanze di Derby avviano lo stesso database contemporaneamente, potrebbe verificarsi un errore grave o irreversibile. La propriet\u00E0 derby.database.forceDatabaseLock=true \u00E8 stata impostata, pertanto il database non verr\u00E0 avviato fino a quando db.lck non verr\u00E0 rimosso. In genere tale file viene rimosso alla chiusura della prima istanza di Derby che avvia il database, tuttavia in alcune occasioni ci\u00F2 non si verifica. In tal caso, il file dovr\u00E0 essere rimosso manualmente. Prima di eliminare il file db.lck manualmente, \u00E8 importante verificare che nessun''altra macchina virtuale acceda al database.

# Arguments:
#
#    {0} = containerName
#
XSDB9.D=Il contenitore di flusso {0} \u00E8 corrotto.

# Arguments:
#
#    {0} = object
#
XSDBA.D=Tentativo di allocare l''oggetto {0} non riuscito.

# Arguments:
#
#    {0} = page
#    {1} = hexDump
#
XSDBB.D=Formato pagina sconosciuto alla pagina {0}, segue il dump di pagina: {1} 

# Arguments:
#
#    {0} = container
#
XSDBC.D=Impossibile scrivere le informazioni sul contenitore nella pagina 0 del contenitore {0}. Per ulteriori informazioni, vedere l''errore nidificato.  

# Arguments:
#
#    {0} = fileName
#
XSDF0.S=Impossibile creare il file {0} poich\u00E9 gi\u00E0 esistente.

# Arguments:
#
#    {0} = fileName
#
XSDF1.S=Eccezione durante la creazione del file {0} per il contenitore

# Arguments:
#
#    {0} = fileName
#    {1} = exceptionText
#
XSDF2.S=Eccezione durante la creazione del file {0} per il contenitore, impossibile eliminare il file. L''eccezione era: {1}.

# Arguments:
#
#    {0} = segmentName
#
XSDF3.S=Impossibile creare il segmento {0}.

# Arguments:
#
#    {0} = fileName
#    {1} = detailedException
#
XSDF4.S=Eccezione durante la rimozione del file {0} per il contenitore rilasciato; impossibile eliminare il file {1}.

# Arguments:
#
#    {0} = page
#
XSDF6.S=Impossibile trovare la pagina di allocazione {0}.

# Arguments:
#
#    {0} = pageKey
#
XSDF7.S=Non \u00E8 stato possibile bloccare la pagina appena creata {0}

# Arguments:
#
#    {0} = page
#
XSDF8.S=Impossibile trovare la pagina {0} da riutilizzare.

XSDFB.S=Operazione non supportata da un database di sola lettura

# Arguments:
#
#    {0} = page
#    {1} = hexDump
#    {2} = hexDump
#
XSDFD.S=Lettura immagini pagine differenti su 2 I/O sulla pagina {0}, la prima immagine ha un checksum errato, la seconda ha un checksum corretto. Di seguito vengono riportate le immagini delle pagine: {1} {2}

XSDFF.S=Operazione richiesta non riuscita a causa di un''eccezione imprevista.

# Arguments:
#
#    {0} = fileName
#
XSDFH.S=Impossibile effettuare il backup del database, rilevata un''eccezione I/O durante la scrittura nel file contenitore di backup {0}.

# Arguments:
#
#    {0} = page
#
XSDFI.S=Errore rilevato durante il tentativo di scrivere i dati sul disco durante il ripristino del database. Verificare che il disco del database non sia pieno. In case positivo, eliminare i file non necessari e tentare nuovamente il collegamento al database. Inoltre, \u00E8 possibile che il file system sia di sola lettura, che il disco presenti degli errori o che si siano verificati dei problemi con i supporti. Il sistema ha rilevato un errore durante l''elaborazione della pagina {0}.

# Arguments:
#
#    {0} = fileName
#
XSDFJ.S=Rilevato errore durante il tentativo di rimozione del file di database {0} nell''ambito dell''operazione di cifratura o decifrazione dei file di database. La mancata rimozione del file pu\u00F2 essere dovuta alla propriet\u00E0 errata o ad autorizzazioni errate per il file o per la directory. All''origine dell''errore potrebbero esservi inoltre processi non controllati da Derby, ad esempio gli strumenti di controllo dei backup o dei virus.

# Arguments:
#
#    {0} = fileName
#
XSDFK.S=Rilevato errore durante il tentativo di rimozione del file JAR {0} memorizzato nel database. La mancata rimozione del file pu\u00F2 essere dovuta alla propriet\u00E0 errata o ad autorizzazioni errate per il file o per la directory. All''origine dell''errore potrebbero esservi inoltre processi non controllati da Derby, ad esempio gli strumenti di controllo dei backup o dei virus.

# Arguments:
#
#    {0} = page
#
XSDG0.D=Impossibile leggere la pagina {0} dal disco.

# Arguments:
#
#    {0} = page
#
XSDG1.D=Impossibile scrivere la pagina {0} sul disco. Verificare che il disco non sia pieno o che non sia stato raggiunto un limite del file system quale il limite di quota o di dimensione massima del file.

# Arguments:
#
#    {0} = page
#    {1} = number
#    {2} = number
#    {3} = hexDump
#
XSDG2.D=Checksum non valido sulla Pagina {0}, previsto={1}, versione su disco={2}, segue dump di pagina: {3}

# Arguments:
#
#    {0} = containerName
#    {1} = type
#    {2} = file
#
XSDG3.D=Impossibile accedere ai metadati di {0} per {1} {2}

# Arguments:
#
#    {0} = pageArrayLength
#    {1} = containerArrayLength
#    {2} = maxBorrowedSpace
#    {3} = borrowedSpaceOffset
#    {4} = borrowedSpaceLength
#    {5} = arraycopySourcePosition
#    {6} = maxBorrowableSpace
#    {7} = hexdump
#
XSDG4.D=Rilevato errore interno irreversibile durante il tentativo di lettura dei metadati di basso livello relativi alla tabella o all''indice. Fornire alla propria organizzazione di supporto le informazioni di eccezione seguenti: Operazione non riuscita: arraycopy del byte[{0}] della pagina embrionica nel byte[{1}] delle informazioni contenitore. Valori delle variabili e delle costanti: MAX_BORROWED_SPACE: {2}, BORROWED_SPACE_OFFSET({3}) + BORROWED_SPACE_LENG({4}) = {5}; arraycopylength: {6}; pagina embrionica {7}.

XSDG5.D=Il database non si trova in modalit\u00E0 di creazione quando viene chiamato createFinished.

# Arguments:
#
#    {0} = directoryPath
#
XSDG6.D=Directory di segmenti di dati non trovata nella copia di backup {0} durante il ripristino. Verificare che la copia di backup sia corretta e che non sia danneggiata.

# Arguments:
#
#    {0} = directoryName
#
XSDG7.D=Impossibile eliminare la directory {0} durante il ripristino. Verificare di disporre delle autorizzazioni richieste per la directory.

# Arguments:
#
#    {0} = directoryName
#    {1} = directoryName
#
XSDG8.D=Impossibile copiare la directory ''{0}'' in ''{1}'' durante il ripristino. Verificare di disporre dello spazio necessario e delle autorizzazioni richieste. 

XSDG9.D=Il thread Derby ha ricevuto un interrupt durante l''operazione I/O su disco. Verificare l''origine dell''interrupt nell''applicazione.

# Arguments:
#
#    {0} = filePath
#
XSLA0.D=Impossibile scaricare il file di log sul disco {0}.

# Arguments:
#
#    {0} = object
#
XSLA1.D=Record di log inviato al flusso ma non applicabile alla memoria (Oggetto {0}). Ci\u00F2 pu\u00F2 causare dei problemi di ripristino.

XSLA2.D=Il sistema verr\u00E0 arrestato, rilevata eccezione I/O durante l''accesso al file di log.

XSLA3.D=Log danneggiato, dati non validi presenti nel flusso di log.

XSLA4.D=Rilevato errore durante il tentativo di scrittura nel log di recupero delle transazioni. \u00C8 probabile che il disco che contiene il log di recupero sia pieno. Se il disco \u00E8 effettivamente pieno, l''unico modo per continuare consiste nel liberare spazio mediante l''espansione del disco o l''eliminazione di file non correlati a Derby. \u00C8 inoltre possibile che il file system e/o il disco in cui si trova il log delle transazioni Derby sia di sola lettura. L''errore pu\u00F2 essere rilevato anche in caso di errore del disco o del file system.

# Arguments:
#
#    {0} = transactionID
#
XSLA5.D=Impossibile leggere il flusso di log per eseguire il rollback della transazione {0}.

XSLA6.D=Impossibile ripristinare il database.

# Arguments:
#
#    {0} = operation
#
XSLA7.D=Impossibile ripetere l''operazione {0} nel log.

# Arguments:
#
#    {0} = transactionID
#    {1} = undoableOperation
#    {2} = compensationOperation
#
XSLA8.D=Impossibile eseguire il rollback della transazione {0}; tentativo di compensare l''operazione {1} con {2}

XSLAA.D=La memoria \u00E8 stata contrassegnata per l''arresto da un''eccezione precedente.

# Arguments:
#
#    {0} = logfileName
#
XSLAB.D=Impossibile trovare il file di log {0}, assicurarsi che la propriet\u00E0 logDevice sia impostata correttamente con l''adeguato separatore di percorso compatibile con la piattaforma utilizzata.

# Arguments:
#
#    {0} = directoryPath
#
XSLAC.D=Il database su {0} dispone di un formato non compatibile con la versione corrente del software; \u00E8 possibile che sia stato creato o aggiornato con una versione successiva.

# Arguments:
#
#    {0} = length
#    {1} = length
#    {2} = logInstant
#    {3} = logfileName
#
XSLAD.D=Record di log nella classe instant {2} nel file di log {3} danneggiato. Lunghezza prevista record di log {0}, lunghezza effettiva {1}.

# Arguments:
#
#    {0} = fileName
#
XSLAE.D=Impossibile scrivere o aggiornare il file di controllo su {0}.

XSLAF.D=Database di sola lettura creato con buffer dati danneggiati.

XSLAH.D=Database di sola lettura in fase di aggiornamento.

XSLAI.D=Impossibile registrare il record di log checkpoint

XSLAJ.D=Il sistema di registrazione \u00E8 stato contrassegnato per l''arresto a causa di un problema precedente e non consentir\u00E0 di eseguire altre operazioni fino a quando il sistema non verr\u00E0 arrestato e riavviato.

# Arguments:
#
#    {0} = number
#
XSLAK.D=Il database ha superato il numero massimo di file di log {0}.

# Arguments:
#
#    {0} = logfileName
#    {1} = position
#    {2} = size
#    {3} = size
#
XSLAL.D=La dimensione del record di log {2} ha superato la dimensione massima consentita {3}. Errore riscontrato nel file di log {0}, posizione {1}.

# Arguments:
#
#    {0} = exceptionDetails
#    {1} = directoryPath
#
XSLAM.D=Impossibile verificare il formato del database su {1} a causa di IOException: {0}

# Arguments:
#
#    {0} = directoryPath
#    {1} = versionNumber
#
XSLAN.D=Il database su {0} dispone di un formato non compatibile con la versione corrente del software. Il database \u00E8 stato creato o aggiornato tramite la versione {1}.

# Arguments:
#
#    {0} = detailedMessage
#
XSLAO.D=Ripristino del problema imprevisto non riuscito: {0}.

# Arguments:
#
#    {0} = directoryPath
#    {1} = versionNumber
#
XSLAP.D=La versione del database su {0} \u00E8 {1}. Le versioni beta dei database non possono essere aggiornate.

# Arguments:
#
#    {0} = directoryName
#
XSLAQ.D=Impossibile creare il file di log nella directory {0}.

# Arguments:
#
#    {0} = logfileName
#    {1} = logFileName
#
XSLAR.D=Impossibile copiare il file di log ''{0}'' in ''{1}'' durante il ripristino. Verificare di disporre dello spazio necessario e delle autorizzazioni richieste. 

# Arguments:
#
#    {0} = directoryName
#
XSLAS.D=Directory di log {0} non trovata nella copia di backup durante il ripristino. Verificare che la copia di backup sia corretta e che non sia danneggiata.

# Arguments:
#
#    {0} = directoryName
#
XSLAT.D=La directory di log ''{0}'' esiste. La directory potrebbe appartenere a un altro database. Verificare che l''ubicazione specificata per l''attributo logDevice sia corretta.

# Arguments:
#
#    {0} = logOperation
#
XSLB1.S=L''operazione di log {0} riscontra degli errori durante la scrittura al di fuori del flusso di log; ci\u00F2 pu\u00F2 essere determinato da un''operazione di log errata o dal buffer log interno saturo a causa di un''operazione di log di dimensioni eccessive.

# Arguments:
#
#    {0} = logOperation
#
XSLB2.S=Operazione di log {0} con registrazione di dati in eccesso; buffer interno del log saturo.

# Arguments:
#
#    {0} = logInstant
#    {1} = truncationPoint
#    {2} = logInstant
#    {3} = logInstant
#
XSLB5.S=Classe instant truncationLWM {1} non valida per il punto di interruzione {0}. L''intervallo valido \u00E8 compreso tra {2} e {3}.

XSLB6.S=Tentativo di registrare un Record di log di lunghezza 0 o -ve.

# Arguments:
#
#    {0} = logInstant
#    {1} = logInstant
#
XSLB8.S=Tentativo di ripristinare una scansione su {0}, oltre il limite di {1}.

XSLB9.S=Impossibile eseguire ulteriori modifiche, la produzione di log \u00E8 stata arrestata.

XSRS0.S=Impossibile bloccare il database dopo che \u00E8 gi\u00E0 stato bloccato.

# Arguments:
#
#    {0} = directoryPath
#
XSRS1.S=Impossibile eseguire il backup del database su {0}, poich\u00E9 non \u00E8 una directory.

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XSRS4.S=Errore durante la ridenominazione del file (durante il backup) da {0} a {1}.

# Arguments:
#
#    {0} = path
#    {1} = path
#
XSRS5.S=Errore durante la copia del file (durante il backup) da {0} a {1}.

# Arguments:
#
#    {0} = directoryName
#
XSRS6.S=Impossibile creare la directory di backup {0}.

XSRS7.S=Il backup ha rilevato un''eccezione imprevista.

XSRS8.S=L''unit\u00E0 di log pu\u00F2 essere impostata solo durante il periodo di creazione del database e non pu\u00F2 essere modificata durante l''esecuzione.

# Arguments:
#
#    {0} = recordName
#
XSRS9.S=Il record {0} non esiste pi\u00F9

XSRSA.S=Impossibile effettuare il backup del database quando non \u00E8 stato eseguito il commit di operazioni non registrate. Effettuare il commit delle transazioni con operazioni di blocco del backup. 

XSRSB.S=Impossibile effettuare il backup in una transazione con operazioni non registrate di cui non \u00E8 stato eseguito il commit.

# Arguments:
#
#    {0} = directoryLocation
#
XSRSC.S=Impossibile effettuare il backup del database su {0}, \u00E8 una directory del database.

XSTA2.S=Una transazione era gi\u00E0 attiva quando si \u00E8 tentato di attivarne un''altra.

XSTB0.M=\u00C8 stata restituita un''eccezione durante l''interruzione della transazione.

XSTB2.M=Impossibile registrare le modifiche della transazione, probabilmente si \u00E8 tentato di effettuare la scrittura su un database di sola lettura.

XSTB3.M=Impossibile interrompere la transazione poich\u00E9 il gestore log \u00E8 nullo, probabilmente a causa di un errore precedente.

XSTB5.M=\u00C8 stato riscontrato un errore imprevisto durante il tentativo di creare un database con la registrazione disabilitata.

XSTB6.M=Impossibile sostituire una tabella transazioni con un''altra quando una \u00E8 gi\u00E0 in uso.

XXXXX.C.6=Chiusura sessione database normale.

02000=Nessuna riga \u00E8 stata trovata per FETCH, UPDATE o DELETE oppure il risultato di una query \u00E8 una tabella vuota.

# Arguments:
#
#    {0} = operatorName
#    {1} = detailedError
#
10000=Rilevato un errore durante il calcolo dell''espressione query XML per l''operatore {0}: {1}

42Z00.U=Chiamata metodo Java o riferimento campo

42Z01.U=Senza tipo

# Arguments:
#
#    {0} = javaClassName
#
42Z10=La classe Java associata a un tipo definito dall''utente potrebbe non essere una classe utilizzata internamente da Derby: ''{0}''.

# Arguments:
#
#    {0} = dataType
#
42Z12.U=Errore interno: tentativo non valido di accedere a {0} come flusso

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z30.U=tempo impiegato in ResultSet =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z31.U=tempo impiegato in ResultSet e in quelle successive =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z32.U=suddivisione tempo totale: 

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z33.U=tempo costruttore (millisecondi) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z34.U=tempo di apertura (millisecondi) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z35.U=tempo successivo (millisecondi) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z36.U=tempo di chiusura (millisecondi) =

# Translators: This is part of query plan printout; the string is complete as is.
# This is a start or stop position for a scan.
#
42Z37.U=Nessuno

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z38.U=Posizionamento delle informazioni non disponibile poich\u00E9 ResultSet non \u00E8 stato mai aperto.

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = exceptionMessage
#
42Z39.U=Eccezione imprevista {0} durante il recupero del posizionatore.

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = searchOperator
#    {1} = number
#
42Z40.U={0} sulle prime {1} colonne.

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z41.U=Righe consecutive con valori nulli sulle seguenti colonne: 

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z42.U=ID colonna

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z43.U=Operatore

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z44.U=Valori nulli ordinati

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z45.U=Valore di ritorno sconosciuto

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z46.U=Annulla risultato confronto

# Arguments:
#
#    {0} = className
#
42Z47.U=Il recupero del piano query come una Stringa non \u00E8 al momento supportato per {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = term
#    {1} = columnNumber
#
42Z48.U=ID colonna [{0}][{1}]

42Z54.U=Questa eccezione arresta l''istruzione in seguito all''analisi - non \u00E8 necessaria un''ulteriore elaborazione.

42Z55.U=Esecuzione arrestata in seguito all''analisi tramite il flag di debug StopAfterParsing.

42Z56.U=Esecuzione arrestata in seguito al collegamento tramite il flag di debug StopAfterBinding.

42Z57.U=Esecuzione arrestata in seguito all''ottimizzazione tramite il flag di debug StopAfterOptimizing.

42Z58.U=Esecuzione arrestata in seguito alla generazione tramite il flag di debug StopAfterGenerating.

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z80.U=serializzabile

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z81.U=lettura di cui \u00E8 stato eseguito il commit

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
# This is shorthand for "exclusive lock".
#
42Z82.U=esclusivo

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z83.U=condivisione istantanea

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z84.U=condivisione

# A lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z85.U=tabella

# A lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z86.U=riga

# Lock mode and granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z87.U=condividi tabella

# Lock mode and granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z88.U=condividi riga

# Translators: This is part of query plan printout; the string is complete as is.
#
43X00.U=Allegato a

# Translators: This is part of query plan printout; the string is complete as is.
#
43X01.U=Numero iniziale subquery

# Translators: This is part of query plan printout; the string is complete as is.
#
43X02.U=Qualsiasi ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X03.U=Numero di aperture

# Translators: This is part of query plan printout; the string is complete as is.
#
43X04.U=Righe visualizzate

# Translators: This is part of query plan printout; the string is complete as is.
#
43X05.U=Set dei risultati di origine

# Translators: This is part of query plan printout; the string is complete as is.
#
43X06.U=Numero finale subquery

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43X07.U=conteggio righe calcolate dall''ottimizzatore: {0,number,###########0.00}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43X08.U=costo calcolato dall''ottimizzatore: {0,number,###########0.00}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X09.U=secondi

# Translators: This is part of query plan printout; the string is complete as is.
#
43X11.U=Nodo

# Arguments:
#
#    {0} = methodName
#    {1} = className
#
43X12.U={0} attualmente non implementato per {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X13.U=Elimina ResultSet tramite

# Lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
43X14.U=blocco tabella

# Lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
43X15.U=blocco righe

# Translators: This is part of query plan printout; the string is complete as is.
# This is shorthand for "deferred update".
#
43X16.U=rinviato

# Translators: This is part of query plan printout; the string is complete as is.
#
43X17.U=Righe eliminate

# Translators: This is part of query plan printout; the string is complete as is.
#
43X18.U=Indici aggiornati

43X19.U=Elimina

# Translators: This is part of query plan printout; the string is complete as is.
#
43X20.U=ResultSet aggregazione scalare distinta

# Translators: This is part of query plan printout; the string is complete as is.
#
43X21.U=Righe immesse

# Translators: This is part of query plan printout; the string is complete as is.
#
43X22.U=Aggregazione scalare distinta

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43X23.U=ResultSet scansione distinta per {0} che utilizza {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X26.U=ResultSet scansione distinta per {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = isolationLevel
#    {1} = lockString
#
43X27.U=al livello di isolamento {0} utilizzando il blocco {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X28.U=informazioni scansione

# Translators: This is part of query plan printout; the string is complete as is.
#
43X29.U=La colonna Distinct \u00E8 il numero della colonna

# Translators: This is part of query plan printout; the string is complete as is.
#
43X30.U=Le colonne Distinct sono i numeri delle colonne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X31.U=Dimensione tabella hash

# Translators: This is part of query plan printout; the string is complete as is.
#
43X32.U=Righe filtrate

# Translators: This is part of query plan printout; the string is complete as is.
#
43X33.U=tempo successivo in millisecondi/riga

# Translators: This is part of query plan printout; the string is complete as is.
#
43X34.U=posizione iniziale

# Translators: This is part of query plan printout; the string is complete as is.
#
43X35.U=posizione finale

# Translators: This is part of query plan printout; the string is complete as is.
#
43X36.U=qualificatori scansione

# Translators: This is part of query plan printout; the string is complete as is.
#
43X37.U=qualificatori dell''operazione successiva

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#
43X38.U=nella tabella {0} tramite {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X39.U=Scansione distinta

# Translators: This is part of query plan printout; the string is complete as is.
#
43X40.U=Ordina informazioni

# Translators: This is part of query plan printout; the string is complete as is.
#
43X41.U=ResultSet aggregazione raggruppata

# Translators: This is part of query plan printout; the string is complete as is.
#
43X42.U=Aggregazione distinta

# Translators: This is part of query plan printout; the string is complete as is.
#
43X43.U=Per ordine

# Translators: This is part of query plan printout; the string is complete as is.
#
43X44.U=Aggregazione raggruppata

# Translators: This is part of query plan printout; the string is complete as is.
#
43X45.U=Hash con join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X46.U=ResultSet hash con join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X47.U=Hash join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X48.U=ResultSet hash join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X49.U=Left outer join hash

# Translators: This is part of query plan printout; the string is complete as is.
#
43X50.U=ResultSet left outer join hash

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43X51.U=ResultSet scansione hash per {0} che utilizza {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X52.U=ResultSet scansione hash per {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X53.U=La chiave hash \u00E8 il numero della colonna

# Translators: This is part of query plan printout; the string is complete as is.
#
43X54.U=Le chiavi hash sono i numeri delle colonne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X55.U=Scansione hash

# Translators: This is part of query plan printout; the string is complete as is.
#
43X56.U=Subquery allegate

# Translators: This is part of query plan printout; the string is complete as is.
#
43X57.U=ResultSet tabella hash

# Translators: This is part of query plan printout; the string is complete as is.
#
43X58.U=Tabella hash

# Translators: This is part of query plan printout; the string is complete as is.
# Shorthand for "all columns".
#
43X59.U=tutto

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X60.U=ResultSet da riga indice a riga base per {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X61.U=Colonne cui si accede dallo heap

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X62.U=per {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X63.U=Da riga indice a riga base

# Translators: This is part of query plan printout; the string is complete as is.
#
43X64.U=modalit\u00E0 di inserimento: inserimento di massa

# Translators: This is part of query plan printout; the string is complete as is.
#
43X65.U=modalit\u00E0 di inserimento: normale (impossibile eseguire l''inserimento di una nuova serie di righe a causa della mancanza di una tabella vuota)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X66.U=modalit\u00E0 di inserimento: normale

# Translators: This is part of query plan printout; the string is complete as is.
#
43X67.U=ResultSet inserimento che utilizza

# Translators: This is part of query plan printout; the string is complete as is.
#
43X68.U=Righe inserite

# Translators: This is part of query plan printout; the string is complete as is.
#
43X69.U=Inserisci

# Translators: This is part of query plan printout; the string is complete as is.
#
43X70.U=Join

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#
43X71.U=ResultSet scansione indica ultima chiave per {0} che utilizza l''indice {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = isolationLevel
#    {1} = lockString
#
43X72.U=al livello di isolamento {0} utilizzando il blocco {1} scelto dall''ottimizzatore

# Translators: This is part of query plan printout; the string is complete as is.
#
43X73.U=Scansione tabella

# Translators: This is part of query plan printout; the string is complete as is.
#
43X74.U=Scansione indice

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X75.U=su {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X76.U=ResultSet materializzato

# Translators: This is part of query plan printout; the string is complete as is.
#
43X77.U=tempo di creazione conglomerato temporaneo (millisecondi)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X78.U=tempo di lettura in sequenza conglomerato temporaneo (millisecondi)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X79.U=Righe visualizzate da sinistra

# Translators: This is part of query plan printout; the string is complete as is.
#
43X80.U=Righe visualizzate da destra

# Translators: This is part of query plan printout; the string is complete as is.
#
43X81.U=Righe restituite

# Translators: This is part of query plan printout; the string is complete as is.
#
43X82.U=Set di risultati di sinistra

# Translators: This is part of query plan printout; the string is complete as is.
#
43X83.U=Set di risultati di destra

# Translators: This is part of query plan printout; the string is complete as is.
#
43X84.U=Loop nidificato con join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X85.U=ResultSet loop nidificato con join

# Translators: This is part of query plan printout; the string is complete as is.
#
43X86.U=Join loop nidificato

# Translators: This is part of query plan printout; the string is complete as is.
#
43X87.U=ResultSet join loop nidificato

# Translators: This is part of query plan printout; the string is complete as is.
#
43X88.U=Righe di destra vuote restituite

# Translators: This is part of query plan printout; the string is complete as is.
#
43X89.U=Left outer join loop nidificato

# Translators: This is part of query plan printout; the string is complete as is.
#
43X90.U=ResultSet left outer join loop nidificato

# Translators: This is part of query plan printout; the string is complete as is.
#
43X91.U=ResultSet normalizzazione

# Translators: This is part of query plan printout; the string is complete as is.
#
43X92.U=ResultSet con valore singolo

# Translators: This is part of query plan printout; the string is complete as is.
#
43X93.U=ResultSet restituzione progetto

# Translators: This is part of query plan printout; the string is complete as is.
#
43X94.U=limitazione

# Translators: This is part of query plan printout; the string is complete as is.
#
43X95.U=proiezione

# Translators: This is part of query plan printout; the string is complete as is.
#
43X96.U=tempo di limitazione (millisecondi)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X97.U=tempo di proiezione (millisecondi)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X98.U=Restituzione progetto

# Translators: This is part of query plan printout; the string is complete as is.
#
43X99.U=ResultSet riga

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9A.U=ResultSet conteggio righe

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9B.U=Conteggio righe

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9C.U=ResultSet finestra: 

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y00.U=ResultSet aggregazione scalare

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y01.U=Ottimizzazione chiave indice

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y02.U=Aggregazione scalare

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y03.U=ResultSet non sensibile allo scorrimento

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y04.U=Numero di letture dalla tabella hash

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y05.U=Numero di scritture sulla tabella hash

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y06.U=ResultSet ordinamento

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y07.U=Elimina duplicati

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y08.U=Ordinamento

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43Y09.U=ResultSet scansione indice per {0} che utilizza {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43Y10.U=ResultSet scansione tabella per {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y11.U=Blocco attuale utilizzato: blocco livello tabella.

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y12.U=Dimensione lettura in sequenza

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y13.U=qualificatori

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y14.U=ResultSet unione

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableOrRow
#
43Y16.U=ResultSet aggiornamento che utilizza il blocco {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y17.U=Righe aggiornate

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = javaClassName
#
43Y19.U=ResultSet VTI per {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y20.U=VTI

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y21.U=Subquery materializzate

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y22.U=Nome istruzione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y23.U=Test istruzione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y24.U=Tempo di analisi

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y25.U=Tempo di collegamento

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y26.U=Tempo di ottimizzazione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y27.U=Tempo di creazione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y28.U=Tempo di compilazione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y29.U=Tempo di esecuzione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y30.U=Indicatore data/ora iniziale di compilazione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y31.U=Indicatore data/ora finale di compilazione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y32.U=Indicatore data/ora iniziale di esecuzione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y33.U=Indicatore data/ora finale di esecuzione

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y44.U=Testo normale di esecuzione istruzione

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43Y45.U=Runtime 100%, {0} secondi

43Y46.U=Inserisci ResultSet VTI

43Y47.U=Elimina ResultSet VTI

43Y49.U=Inserisci VTI

43Y50.U=Elimina VTI

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y51.U=Elimina ResultSet a catena

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y52.U=Elimina ResultSet a catena tramite

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y53.U=Azioni di riferimento su tabelle dipendenti

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y54.U=Inizio azione di riferimento sul numero di tabella dipendente

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y55.U=Fine azione di riferimento sul numero di tabella dipendente

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = userSuppliedOptimizerOverrides
#
43Y56.U=Le sostituzioni dell''ottimizzatore fornite dall''utente su {0} sono {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = userSuppliedOptimizerOverrides
#
43Y57.U=Le sostituzioni dell''ottimizzatore fornite dall''utente per il join sono {0}

44X00.U=Nome tipo SQL

# Arguments:
#
#    {0} = url
#
46001=Eccezione durante l''accesso al file jar tramite l''URL ''{0}''.

46J01=La firma del metodo Java ha un formato non valido.

# Arguments:
#
#    {0} = number
#    {1} = number
#
46J02=La firma del metodo Java contiene un numero errato ({0}) di parametri, previsti {1}.

# Arguments:
#
#    {0} = prefix
#
54002=Una costante di stringa che inizia con ''{0}'' \u00E8 troppo lunga.

54004=L''istruzione SELECT presenta un numero eccessivo di elementi nella lista GROUP BY, ORDER BY o SELECT.

# Arguments:
#
#    {0} = operator
#    {1} = number
#
54006=La lunghezza risultante dall''operazione {0} \u00E8 maggiore di {1}.

54008=L''istruzione CREATE INDEX specifica un numero eccessivo di colonne (16 \u00E8 il numero massimo consentito).

# Arguments:
#
#    {0} = number
#    {1} = tableOrViewName
#    {2} = number
#
54011=Troppe colonne ({0}) sono state specificate per la tabella o la vista {1}. Il limite \u00E8 {2}.

54038=La profondit\u00E0 massima dei trigger nidificati \u00E8 stata superata.

BIN01=(Valore dati binari non visualizzato)

# Arguments:
#
#    {0} = columnName
#
S0022=Colonna ''{0}'' non trovata.

# Arguments:
#
#    {0} = errorMessage
#    {1} = exceptionClassName
#
XJ001.U=Eccezione Java: ''{1}: {0}''.

# Arguments:
#
#    {0} = oldVersion
#    {1} = newVersion
#
XJ050.U=\u00C8 necessario aggiornare il database dalla versione {0}; impostare l''attributo ''upgrade=true sull''URL della connessione JDBC per consentire l''aggiornamento alla versione {1}.

XJ082.U=I valori BLOB/CLOB non sono consentiti come parametri di metodo o destinatari.

# Arguments:
#
#    {0} = operation
#
XJ083.U=''{0}'' non consentito perch\u00E9 ResultSet non \u00E8 un ResultSet aggiornabile. 

# Arguments:
#
#    {0} = methodName
#
XJ084.U=La colonna non corrisponde a una colonna della tabella di database. Impossibile inoltrare ''{0}'' su questa colonna.

# Arguments:
#
#    {0} = xmlPackageName
#
XML00=Impossibile individuare ''{0}'' API o classi di implementazione. Le operazioni XML non sono consentite a meno che queste classi non si trovano nel classpath.

# Arguments:
#
#    {0} = errorMessage
#
XML01=Rilevato un errore imprevisto durante l''elaborazione di XML: {0}

XN002.U=SECTKN non restituito.

XSAJ0.U=Tipo di scansione

XSAJ1.U=Numero di pagine visitate

XSAJ2.U=Numero di righe visitate

XSAJ3.U=Numero di righe eliminate visitate

XSAJ4.U=Numero di righe completate

XSAJ5.U=Numero di colonne lette in sequenza

XSAJ6.U=Bit impostato di colonne lette in sequenza

XSAJ7.U=Altezza struttura

XSAJ8.U=Tipo di ordinamento

XSAJA.U=Numero di righe in input

XSAJB.U=Numero di righe in output

XSAJC.U=Numero di esecuzioni unione

XSAJD.U=Dimensione delle esecuzioni unione

XSAJE.U=Tutto

# This is a type of conglomerate.
#
XSAJF.U=btree

# This is a type of conglomerate.
#
XSAJG.U=heap

XSAJH.U=ordinamento

# This is a type of sort.
#
XSAJI.U=esterno

# This is a type of sort.
#
XSAJJ.U=interno

A001=Irreversibile: non esiste alcun servizio di autenticazione per il sistema

A002=Irreversibile: non esiste alcun servizio di autenticazione per il database

# Arguments:
#
#    {0} = propertyName
#
A011=Avvertenza: nessun nome server/host LDAP menzionato nella propriet\u00E0 {0}; viene utilizzato localhost:389

A020=Autenticazione non valida.

# Arguments:
#
#    {0} = className
#    {1} = fileName
#    {2} = errorMessage
#
C000=Classe {0} scritta sul file {1}. Fornire il supporto tramite il file e le seguenti informazioni relative all''eccezione: {2}

# Arguments:
#
#    {0} = className
#    {1} = jarName
#
C001=La classe {0} dispone di un tipo di certificato sconosciuto in jar {1}, previsto certificato X509.

# Arguments:
#
#    {0} = className
#    {1} = jarName
#    {2} = errorMessage
#
C002=Eccezione di sicurezza restituita durante l''accesso alla classe {0} in jar {1} : {2}

# Arguments:
#
#    {0} = jarName
#    {1} = errorMessage
#
C003=Eccezione durante il caricamento del database jar {0} - {1}

# Arguments:
#
#    {0} = className
#
C004=Programma di caricamento classi non pi\u00F9 valido per la classe {0}

# Arguments:
#
#    {0} = classpath
#
C005=Programma di caricamento classe database avviato - derby.database.classpath=''{0}''

# Arguments:
#
#    {0} = className
#    {1} = jarName
#
C006={0} \u00E8 stato caricato dal database jar {1}

# Arguments:
#
#    {0} = className
#    {1} = jarName
#    {2} = detailedError
#
C007=Eccezione durante il caricamento della classe {0} da jar {1} - {2}

# Arguments:
#
#    {0} = className
#    {1} = detailedError
#
C008=Eccezione durante il caricamento della classe {0}: {1}

# Arguments:
#
#    {0} = derbyVersion
#    {1} = id
#    {2} = directoryName
#    {3} = classloader
#    {4} = JarClassPath
#
D000=:\nAvvio dell''istanza {1} di Derby (versione {0}) \nsulla directory di database {2} in modalit\u00E0 SOLA LETTURA con caricatore classi {3}. \nCaricato da {4}

# Arguments:
#
#    {0} = derbyVersion
#    {1} = id
#    {2} = directoryName
#    {3} = classloader
#    {4} = JarClassPath
#
D001=:\nAvvio della versione di Derby {0}: istanza {1}\nsulla directory di database {2} con caricatore classi {3} \nCaricato da {4}

# Arguments:
#
#    {0} = id
#    {1} = dbDirectory
#    {2} = classloader
#
D002=:\nArresto dell''istanza {0} nella directory del database {1} con il caricatore di classi {2} 

# Arguments:
#
#    {0} = databaseName
#    {1} = filePath
#
D004=Backup avviato per il database situato in {0} a {1}.

# Arguments:
#
#    {0} = filePath
#    {1} = filePath
#
D005=Vecchia copia di backup spostata da {0} a {1}

# Arguments:
#
#    {0} = filePath
#
D006=Backup del segmento di dati a {0} completato. 

D007=database service.properties modificato per utilizzare il dispositivo di log predefinito

# Arguments:
#
#    {0} = errorMessage
#
D008=Errore durante la modifica del database service.properties; backup interrotto: {0}

# Arguments:
#
#    {0} = filePath
#    {1} = filePath
#
D009=Directory di log copiata da {0} a {1}

D010=Backup interrotto a causa di un errore

# Arguments:
#
#    {0} = filePath
#
D011=Vecchia copia di backup eliminata in {0}

# Arguments:
#
#    {0} = backupInstant
#
D012=Backup completato, classe instant di log su {0} \n

# Arguments:
#
#    {0} = durabilityProperty
#    {1} = noSync
#
D013=Avvertenza: il database viene avviato con {0}={1}. In questa modalit\u00E0, \u00E8 possibile che il database non possa essere ripristinato, che le transazioni di cui \u00E8 stato eseguito il commit vadano perdute e che il database si trovi in uno stato incoerente. Utilizzare questa modalit\u00E0 solo quando tali conseguenze sono accettabili \n

D015=Un''altra transazione ha modificato il valore. Impossibile continuare a leggere.

# Arguments:
#
#    {0} = pageId
#    {1} = overFlow
#    {2} = pageVersion
#    {3} = slotsInUse
#    {4} = deletedRowCount
#    {5} = pageStatus
#    {6} = nextId
#    {7} = firstFreeByte
#    {8} = freeSpace
#    {9} = totalSpace
#    {10} = spareSpace
#    {11} = minimumRecordSize
#    {12} = pageSize
#    {13} = hexPageDump
#
D016=\n---------------------------------------------------\nID pagina:            {0}\n Overflow:          {1}\n PageVersion:       {2}\n SlotsInUse:        {3}\n DeletedRowCount:   {4}\n PageStatus:        {5}\n NextId:            {6}\n firstFreeByte:     {7}\n freeSpace:         {8}\n totalSpace:        {9}\n spareSpace:        {10}%\n minimumRecordSize: {11}\n PageSize:          {12}\n---------------------------------------------------\n{13}\n---------------------------------------------------

I024=Database non disponibile

I025=Driver JDBC non disponibile

# Arguments:
#
#    {0} = errorMessage
#
I026=Registrazione Driver JDBC con java.sql.DriverManager non riuscita: {0}

I027=Nessun contrassegno impostato oppure \u00E8 stato superato il limite per le letture anticipate.

I028=Errore di lettura flusso sul lato client durante il trasferimento dei dati utente al server.

# Arguments:
#
#    {0} = expectedCount
#    {1} = gotCount
#
I029=EOF raggiunta prima del previsto: previsto {0}, ottenuto {1}.

# Arguments:
#
#    {0} = timestamp
#
J003={0}: arresto in corso del motore di Derby

J004=Identit\u00E0 database

J005=Arresta Derby

J006=Annulla la registrazione di AutoloadedDriver

J007=Crea database

J008=Nessun dettaglio

J010=Cifra database su disco

J013=Aggiorna database

J016=Provider servizio crittografico

J017=Algoritmo crittografico

J018=Lunghezza chiave crittografica

J019=Chiave crittografica esterna

J020=Chiave crittografica segreta

J021=Impostazioni nazionali per il database

J022=Nome utente

J023=Password utente

J025=Percorso directory di log

J028=Percorso di backup per il recupero rollforward

J029=Percorso di backup per la creazione di database dal backup

J030=Percorso di backup per il ripristino di database dal backup

J031=Ordinamento per tipi di dati dei caratteri

# Arguments:
#
#    {0} = className
#
J100=Impossibile trovare la classe del server di rete, {0}. Il percorso di classi deve contenere derbynet.jar.

# Arguments:
#
#    {0} = className
#    {1} = errorMessage
#
J101=Impossibile caricare la classe del server di rete, {0}. {1} Verificare l''integrit\u00E0 del file derbynet.jar.

# Arguments:
#
#    {0} = errorMessage
#
J102=\u00C8 stata restituita un''eccezione durante l''avvio del server di rete. {0}

# Arguments:
#
#    {0} = errorMessage
#
J103=\u00C8 stata restituita un''eccezione durante la chiusura del server di rete. {0}

J104=L''oggetto \u00E8 stato gi\u00E0 chiuso.

J105=La precisione supera 31 cifre.

J107=Errore per l''elemento batch #

# Arguments:
#
#    {0} = propertyName
#
J108=Il gestore della sicurezza non consente l''accesso alla propriet\u00E0 del sistema {0}.

# Arguments:
#
#    {0} = errorMessage
#
J109=Rilevata una configurazione del client TCP/IP non corretta. Impossibile determinare l''indirizzo IP dell''host locale: ''{0}''. Accertarsi che la macchina del client abbia un indirizzo IP correttamente configurato.

J110=Meccanismo di sicurezza non supportato

J111=Password mancante

J112=ID utente mancante

J113=ID utente o password non validi

J114=ID utente revocato

J115=Nuova password non valida

J116=Errore del servizio di sicurezza locale per un''operazione che non \u00E8 possibile ritentare.

J117=SECTKN mancante su ACCSEC quando richiesto oppure non valido

J118=Password scaduta

J120=Errore di connessione non specificato

J121=L''utente non \u00E8 autorizzato ad accedere al database.

J122=Un comando richiedente servizi del database \u00E8 stato eseguito prima della richiesta di accesso al database (ACCRDB)

J123=Il comando richiesto ha riscontrato una condizione specifica dell''implementazione e priva di architettura per la quale non era presente alcun messaggio con architettura (ulteriori informazioni eventualmente disponibili nel file derby.log sul server).

J124=Non \u00E8 possibile eseguire il comando ACCRDB (access relational database) perch\u00E9 il database \u00E8 gi\u00E0 in uso.

J125=\u00C8 stato rilevato un errore di mancata corrispondenza del descrittore di dati.

# Arguments:
#
#    {0} = hexNumber
#
J126=\u00C8 stato rilevato un errore del protocollo interattivo. Causa: 0x{0}.

J128=Il cursore non \u00E8 aperto.

J129=\u00C8 stato eseguito un comando di apertura query per una query gi\u00E0 aperta.

J130=\u00C8 stato rilevato un errore di protocollo (errore di descrizione FDOCA non valida).

# Arguments:
#
#    {0} = hexNumber
#
J131=\u00C8 stato rilevato un errore di protocollo (errore di sintassi del datastream). Causa: 0x{0}. Probabilmente si \u00E8 tentato di aprire una connessione di testo normale a un server abilitato per SSL.

J132=Il nome utente per la connessione

J133=La password utente per la connessione

# Arguments:
#
#    {0} = maxStatements
#
J134=Valori negativi per la propriet\u00E0 maxStatements non consentiti: {0}

# Arguments:
#
#    {0} = transactionXid
#
J135=Timeout della transazione XA e rollback in corso. La transazione Xid \u00E8 {0}.

# Arguments:
#
#    {0} = transactionXid
#
J136=Alla connessione chiusa era associata una transazione XA. La transazione verr\u00E0 sottoposta a rollback. La transazione Xid \u00E8 {0}.

J137=Impossibile annullare la registrazione del driver JDBC durante la chiusura del motore Derby. Assicurarsi che SQLPermission("deregisterDriver") sia stato concesso a derby.jar.

L001=------------  Inizio messaggio di errore -------------\n

L002=------------  Fine messaggio di errore -------------\n

L003=\n------------  Inizio arresto stack errori -------------\n

L004=\n------------  Fine arresto stack errori -------------\n

L005=\n------------  Inizio stack errori -------------\n

L006=\n------------  Fine stack errori -------------\n

L007=Avvertenza: file di log non trovato, creazione nuovo log. Possibile incoerenza nel database

# Arguments:
#
#    {0} = fileName
#
L008=Eliminazione vecchio Logfile {0} non compatibile

# Arguments:
#
#    {0} = fileName
#
L009=Eliminazione vecchio Logfile {0}

# Arguments:
#
#    {0} = fileName
#    {1} = position
#    {2} = position
#
L010=\u00C8 stato rilevato un record di log incompleto nel file {0}, durante la cancellazione del file di log dalla posizione {1} alla fine del file {2}.

L011=Il Daemon di checkpoint ha riscontrato l''eccezione standard

# Arguments:
#
#    {0} = transactionID
#
L012=Il record di log non \u00E8 il primo ma la transazione non si trova nella tabella delle transazioni : {0}

# Arguments:
#
#    {0} = transactionID
#
L013=Il record di log \u00E8 il primo ma la transazione si trova gi\u00E0 nella tabella delle transazioni : {0}

L014=Classe instant di avvio errata

# Arguments:
#
#    {0} = fileName
#
L015=Il nuovo file di log esiste e non pu\u00F2 essere eliminato {0}

# Arguments:
#
#    {0} = fileName
#
L016=Impossibile creare un nuovo file di log {0}

# Arguments:
#
#    {0} = fileName
#    {1} = errorMessage
#
L017=Impossibile creare un nuovo file di log {0} a causa di {1}

# Arguments:
#
#    {0} = fileName
#
L018=Il sistema potrebbe trovarsi in uno stato incoerente, file {0} mancante

# Arguments:
#
#    {0} = testModeProperty
#    {1} = testMode
#
L020=Avvertenza: il database \u00E8 stato avviato almeno una volta con {0}={1}. Come risultato dell''utilizzo di questa modalit\u00E0, \u00E8 possibile che il database non possa essere ripristinato, che le transazioni di cui \u00E8 stato eseguito il commit vadano perdute e che il database si trovi in uno stato incoerente. Ci\u00F2 pu\u00F2 causare errori imprevisti.\n

# Arguments:
#
#    {0} = testModeProperty
#    {1} = testMode
#    {2} = testModeProperty
#    {3} = testMode
#
L021=Avvertenza: il database \u00E8 stato precedentemente avviato o viene attualmente avviato con {0} impostato su {1}. Questa modalit\u00E0 {0}={1} non garantisce la capacit\u00E0 di ripristino e probabilmente \u00E8 stata la causa dell''errore di avvio.\n

L022=Avvertenza: a causa di un problema di autorizzazioni per l''accesso ai file di log, lo stato del database \u00E8 stato modificato in sola lettura. \n               

# Arguments:
#
#    {0} = timestamp
#
R001=----  Inizio messaggio di errore della replica ({0}) ----

R002=--------------------  Fine messaggio di errore della replica ---------------------

# Arguments:
#
#    {0} = dbname
#
R003=Ruolo slave di replica avviato per il database ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R004=Ruolo slave di replica interrotto per il database ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R005=Errore irreversibile dello slave di replica per il database ''{0}''. La replica verr\u00E0 interrotta.

# Arguments:
#
#    {0} = dbname
#
R006=Connessione interrotta con il master di replica del database ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R007=Ruolo master di replica avviato per il database ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R008=Ruolo master di replica interrotto per il database ''{0}''.

R009=Eccezione durante l''invio del log.

# Arguments:
#
#    {0} = dbname
#
R010=Tentativo di riconnessione del master di replica allo slave per il database ''{0}''.

# Arguments:
#
#    {0} = dbname
#    {1} = hostname
#    {2} = port
#
R011=Il database slave di replica ''{0}'' ascolta le connessioni del master in ''{1}:{2}''.

R012=Handle di connessione di replica non valido.

# Arguments:
#
#    {0} = timestamp
#    {1} = message
#
R013=Messaggio di replica ({0}): {1}

# Arguments:
#
#    {0} = dbname
#
R020=Failover eseguito correttamente per il database ''{0}''.

# Translators: Please translate the ALL CAPS words.
#
M001=\n# ********************************************************************\n# ***                NON modificare questo file.                 ***\n# *** LA MODIFICA DEL CONTENUTO DI QUESTO FILE POTREBBE CAUSARE IL DANNEGGIAMENTO DEI DATI. ***\n# ********************************************************************

M002=Le propriet\u00E0 di servizio mancanti/danneggiate sono state ripristinate dal file di backup.

M003=File di backup delle propriet\u00E0 di servizio residue eliminato.

# Arguments:
#
#    {0} = servicePropertiesBackupFile
#
M004=Impossibile eliminare il file di backup delle propriet\u00E0 di servizio residue; eliminarlo manualmente: {0}

# Translators: Please translate the ALL CAPS words.
#
M005=\n# *************************************************************************\n# ***              NON MODIFICARE I FILE IN QUESTA DIRECTORY                ***\n# *** I FILE DI QUESTA DIRECTORY E DELLE RELATIVE SOTTODIRECTORY     ***\n# *** COSTITUISCONO IL DATABASE DERBY, CHE INCLUDE I DATI (UTENTE     ***\n# *** E SISTEMA) NONCH\u00C9 I FILE NECESSARI PER IL RECUPERO DEL DATABASE.     ***\n# *** LA MODIFICA, L''AGGIUNTA O L''ELIMINAZIONE DEI FILE PU\u00D2 DANNEGGIARE     ***\n# *** I DATI E LASCIARE IL DATABASE IN UNO STATO NON RECUPERABILE.     ***\n# *************************************************************************

# Translators: Please translate the ALL CAPS words.
#
M006=\n# *************************************************************************\n# ***              DO NOT TOUCH FILES IN THIS DIRECTORY!                ***\n# *** FILES IN THIS DIRECTORY ARE USED BY THE DERBY DATABASE RECOVERY   ***\n# *** SYSTEM. EDITING, ADDING, OR DELETING FILES IN THIS DIRECTORY      ***\n# *** WILL CAUSE THE DERBY RECOVERY SYSTEM TO FAIL, LEADING TO          ***\n# *** NON-RECOVERABLE CORRUPT DATABASES.                                ***\n# *************************************************************************

# Translators: Please translate the ALL CAPS words.
#
M007=\n# *************************************************************************\n# ***              DO NOT TOUCH FILES IN THIS DIRECTORY!                ***\n# *** FILES IN THIS DIRECTORY ARE USED BY THE DERBY DATABASE TO STORE   *** \n# *** USER AND SYSTEM DATA. EDITING, ADDING, OR DELETING FILES IN THIS  ***\n# *** DIRECTORY WILL CORRUPT THE ASSOCIATED DERBY DATABASE AND MAKE     ***\n# *** IT NON-RECOVERABLE.                                               ***\n# *************************************************************************

# Arguments:
#
#    {0} = propertyName
#    {1} = error
#
M008=AVVERTENZA: impossibile leggere la propriet\u00E0 {0} a causa di un''eccezione di sicurezza: {1}. Ci\u00F2 potrebbe costituire un rischio per la sicurezza.\n                

# Arguments:
#
#    {0} = fileName
#    {1} = error
#
M009=Impossibile creare il file o la directory {0} a causa di un''eccezione di sicurezza: {1}.\n                

# Arguments:
#
#    {0} = error
#
M00A=AVVERTENZA: impossibile recuperare il loader di classe del contesto a causa di un''eccezione di sicurezza: {0}. Potrebbe verificarsi la perdita del loader di classe.\n                

# Arguments:
#
#    {0} = error
#
M00B=AVVERTENZA: impossibile impostare il loader di classe del contesto a causa di un''eccezione di sicurezza: {0}. Potrebbe verificarsi la perdita del loader di classe.\n                

# Arguments:
#
#    {0} = error
#
M010=AVVERTENZA: esecuzione di ThreadGroup#setDaemon impossibile sui daemon Derby a causa di un''eccezione di sicurezza: {0}. Questa condizione potrebbe avere effetto sull''operazione.\n                

N001=L''errore \u00E8 provocato dall''errore seguente.
